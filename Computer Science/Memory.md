## 메모리   

- 10진수 : 0 ~ 9    
- 2진수(1bit) : 0 ~ 1     
- 16진수(2^4, 4bit = 1byte) : 0 ~ 9 + A ~ F       
       
##### 16진수 사용처 -> 컴퓨터 메모리, RGB 값 표시(R 2bit, G 2bit, B 2bit)      
- 16진수 사용시, 다른 진수와 헷갈리지 않도록 숫자 앞에 0x 붙이기로 약속. 0x0, 0x1 ...0x1A...        

</br>    

### 1. 메모리 구조      
###### 컴파일러를 만들 때 각각을 메모리 어디에 둘지 정한 것   
- 맨 위(1번 째) : machine code - clang이 컴파일한 0과 1의 값      
- 2번 째 : globals - 전역 변수 or 정보     
- 3번 째 : 힙(heap) - 메모리를 할당받을 수 있는 커다란 영역. malloc를 호출하면 이 영역에서 가져오며, 메모리를 사용할 수록 점점 더 아래로 내려간다.       
- 맨 밑(4번 째) : 스택(stack) - 함수를 호출할 때마다 함수의 지역 변수들이 쌓이는 영역         

###### 힙은 아래로 내려오고, 스택은 점점 쌓여서 올라가므로 제한된 메모리 영역 내에선 언젠가 충돌(힙 오버플로우, 스택 오버플로우)할 수 있다.   

※ 스택 오버플로우 : 자기자신을 계속 호출하는 재귀나 기타 등등의 함수를 계속 호출하여 stack이 넘쳐 기존의 값을 침범하는 현상       

※ 힙 오버플로우 : malloc의 계속된 호출로 너무 많은 메모리를 할당해서 기존의 메모리 속 다른 내용을 덮어쓰는 현상          

</br>   


### 2. 포인터   
##### 컴퓨터의 메모리 주소를 가리킨다.    
##### 추상화를 위해 사용하며, 포인터에 변수의 주소를 저장하면 그때부턴 정확한 주소를 몰라도 포인터가 해당 변수의 주소를 가리키고 있다.     
##### 포인터를 활용하여 정교한 자료형을 만들 수 있고, 수많은 데이터를 관리하기 위해 사용하는 알고리즘의 기초가 된다.   
###### C의 문법에서 &는 '~의 주소'라는 뜻,  ```*```는 그 반대로 '~의 주소로 가라'는 뜻, 즉 값을 나타낸다.    
1. p에 n의 주소 저장, n이 숫자일 때   
``` int *p = &n; ``` -> p = int를 가리키는 포인터(int의 주소)역할을 하는 변수, 주소는 int형에 저장할 수 없으므로 p 앞에 ```*``` 붙여야 한다.    
-> p 앞의 ```*```는 이 변수가 포인터라는 의미   
``` printf("%p\n",p);``` -> 주소 출력   
``` printf("%i\n",*p);``` -> p의 주소에 있는 n의 값 출력       
     

2. s가 문자일 때   
```char *s = "ABCD";```   
``` printf("%c\n",*s);``` -> s의 주소로 가서 값 출력, 즉 첫번째 문자 출력     
``` printf("%c\n",*(s+1));``` -> s+1의 주소로 가서 값 출력, 즉 두번째 문자 출력    
     
     
- 최신 컴퓨터 : 64 bits의 포인터 사용      
- ``` s = "ABCD";``` 여기서 변수 s는 문자열을 가리키는 포인터이며, 가장 첫번째 문자 A의 주소를 가리킨다. 그리고 널 종단 문자에 의해 문자열의 끝 인식      

</br>        

### 3. 메모리 할당         
###### malloc함수와 free함수, realloc 함수는 stdlib 라이브러리 안에 존재   
#### (1) 메모리 할당     
- 메모리의 일부를 힙에서 가져와서 그곳을 가리키는 포인터를 주는 것     
- 메모리 할당 함수 : malloc(메모리크기) - 할당한 메모리의 시작 주소 반환     
ex> 5개의 정수를 저장하는 메모리 : ``` int *a = malloc(5 * sizeof(int)); ``` ,sizeof는 자료형의 크기 표시(정수형 = 4byte)하며     
총 20바이트의 메모리를 할당한다는 뜻      
    
###### ※ 버퍼 오버플로우 - 할당한 메모리 영역을 넘어 접근하는 상황 / 정수 5개를 저장하면 0부터 4까지만 존재하므로 5번째부터 접근하려 한다면 버퍼 오버플로우      

##### (1)-1. 문자열 복사   
- 문자열 t에 대해서 ``` char* s = t```  는 t가 s에 복사되지 않고 단순히 t의 주소만 저장된다.   
- 그래서 ```char* s = malloc(strlen(t) + 1);``` 로 널 종단 문자를 포함한 (t의 길이 + 1) 만큼의 메모리를 할당한 뒤, strcpy 함수로 복사              

#### (2) 메모리 할당 해제      
- 문자열 복사 등 여러 이유로 메모리를 할당하면 작업이 끝난 후 할당을 해제해줘야 메모리 누수 발생 X    
- 할당 해제 함수는 ``` free(s); ``` 로 s는 malloc이 할당해준 메모리의 주소       

#### (3) 메모리 교환      
- swap 함수로 각 값의 포인터 교환      
- 포인터가 아닌 정수값을 받는다면, 함수는 실제 값이 아닌 그 값의 복사본을 교환하기 때문에 실제 값은 변동 X     
- 즉, main 함수의 변수와 swap 함수의 변수는 같은 스택 영역 안 다른 위치에 저장되기 때문에 값을 교환하는 건 서로 영향을 주지 못한다.   
```    
swap(&x, &y)   

void swap(int *a, int *)  // int *a는 정수의 주소를 받아 a라 부른다는 의미       
{ int k = *a;
*a = *b;
*b = k; }   
         
 ```   
 
 #### (4) 메모리 재할당   
- 배열의 크기 조정 등 여러 이유로 이미 할당한 메모리에 크기 조정이 필요하다면, 기존 메모리에 공간을 더하는 것이 아니라 임시 메모리에 재할당한 후 기존 값을 옮겨야 한다.   
- 메모리 재할당 함수는 realloc 함수이며, 재할당과 동시에 기존 값 복사도 이루어진다.    
- 임시메모리 tmp에 k개 정수형 크기만큼 재할당 -> ``` int *tmp = realloc(재할당할 배열명, k * sizeof(int)); ``` 
- 이후엔 ```if(tmp == NULL) {return 1; } ``` 로 메모리 부족할 경우를 체크       
- 마지막엔 free(배열명)으로 메모리 할당 해제   





