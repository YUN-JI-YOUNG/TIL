## 알고리즘     
- 컴퓨터에서 알고리즘 표현 방법     
  - 슈더코드(=의사 코드)       

    - ```python
      def CalcSum(n):
          sum <- 0
          for i in range (1, n+1):
              sum <- sum+i;
          return sum;
      ``` 
  - 순서도    
    - 현재는 잘 쓰이지 않음     

- 성능 판단 척도     
  - 정확성   
  - 작업량   
  - 메모리 사용량   
  - 단순성   
  - 최적성     
 
### 1. 검색 알고리즘   
#### 1-1. 선형 탐색(=linear search)      
##### 배열의 인덱스를 처음부터 하나씩 증가시키면서 탐색하는 방법     
###### - 효율성 : O(n), Ω(1)
의사코드 예시 >   
``` 
for i from 0 to n-1    
　if i번째 요소 = 50   
  　　return true   
return false      
``` 

실제코드 예시 >   
```
int main(void)   
{ 
　int numbers[]={1,4,6,3,18,2,50};   
　
 for(int i = 0; i<7; i++)
{
  if(numbers[i]==50)   
    {
      printf("Found\n");
      return 0;
    }
 }
 printf("Not Found\n");
 return 1;
}
```

</br>


#### 1-2. 이진 탐색(=binary serach)      
##### 배열이 정렬되어있다면, 중간부터 시작하여 찾고자하는 값과 비교해가며 작은 값 혹은 큰 값이 저장되어있는 쪽으로 탐색하는 방법     
###### - 효율성 : O(log n), Ω(1)
ex) 분할 정복 기법    
의사코드 예시 >  
```
if no items  
　return false      
if middle item = 50     
　return true   
if middle item > 50   
　search left half    
if middle item <50    
　search right half   
 ```
 
 </br>     
 
 ### 2. 정렬 알고리즘    
 #### 2-1. 버블 정렬(=bubble sort)            
 ##### 큰 숫자가 올바른 위치로 갈 때까지 움직이는 정렬 방법       
 의사코드 예시1 >   효율성 : O(n^2), Ω(n^2)   
 ```
 Repeat n-1    
 　For i from 0 to n-2   
   　　If i'th and i+1'th elements out of order       
 　Swap them     
  ```
 -> 바깥쪽 반복문은 최대 n-1번 실행, 안쪽 반복문도 최대 n-1번 실행(0 to n-2)이므로 (n-1) x (n-1) = n^2+2n+1 = O(n^2)   
 -> n의 값이 커질수록 n^2의 영향력이 커지므로    
    
 의사코드 예시2 > 효율성 : O(n^2), Ω(n)   
 ```
 Repeat until no swaps   
 　For i from 0 to n-2   
  　If i'th and i+1'th elements out of order   
   Swap them   
   ```
 -> 만약 정렬이 되어있다면 n-1쌍을 모두 확인하여 swap이 일어나지 않으면 종료하니까 하한이 n-1이므로 = Ω(n)   
 
 </br>   
 
 #### 2-2. 선택 정렬(=selection sort)      
 ##### 가장 작은 값을 찾아 1번째 숫자와 바꾸고, 그 다음 작은 값을 찾아 2번째의 숫자와 바꾸는 것을 반복하는 정렬 방법   
 ###### - 효율성 : O(n^2), Ω(n^2)       
 의사코드 예시 >     
```
Repeat n       
 　For i from 0 to n-1   
 　　Find smallest item between i'th item and last item   
  　Swap smallest item with i'th item      
   ```
 -> 제일 적은 숫자를 찾는데 n번, 그 다음 작은 숫자 찾는데 n-1번...이므로 n+(n-1)+(n-2)+...+1 = n(n+1)/2 = (n^2)/2 + n/2 = O(n^2)      
   
 </br>   
 
 #### 2-3. 병합 정렬=(merge sort)     
 ##### 재귀 알고리즘을 활용한 정렬, 왼쪽 절반을 먼저 정렬하고 오른쪽 절반을 정렬하는데, 배열에 값이 1개이면 그대로 반환하는 정렬 방법             
 
 의사코드 예시>
 ```
 If only one item 
 　Return   
 Else
 　Sort left half of items   
 　Sort right half of items   
 　Merge sorted halves   
 ```    
ex> 2 3 5 1 4 9 8 6 : 왼쪽 절반인 2,3,5,1 정렬 -> 왼쪽 절반 2,3 정렬 -> [왼쪽 절반 2 정렬 -> 반환 -> 오른쪽 절반 3 정렬 -> 반환]   
-> 병합 정렬하면 2 3 으로 정렬 -> 다른 배열도 같은 과정 반복    

 ###### 병합 : 두 배열 중 가장 작은 값을 꺼내 다른 배열의 가장 작은 값 다음에 두는 과정      
 
 -> 무언가를 계속 절반으로 나누는 것을 log 함수로 표현하는데 매 단계마다 n번씩 확인을 총 log n 단계 만큼 하므로 n x log n = O(n log n)   
 
 </br>     
 
 #### 2-4. 카운팅 정렬(=counting sort)    
 ###### 집합에 있는 각 항목의 개수를 세는 작업을 한 후, 선형 시간에 정렬하는 효율적인 알고리즘           
- 비교환 방식    
- 각 항목의 발생 회수를 기록하기 위해 정수 항목으로 인덱스되어야 해서 정수 or 정수로  표현가능한 자료에 대해서만 적용 가능        	   
- 시간 복잡도 : O(n+k) : n은 리스트 길이, k는 정수 최대값        
  - for 문이 각각 돌기 때문            
- n,k가 비교적 작을 때만 가능 (범위n는 작은데 값k가 클 수도 있으므로)        


- 과정     
  (1) data에서 각 항목의 발생 회수 세고, 정수 항목으로 인덱스되는 카운트 배열 counts에 저장       
  (2) 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영 (누적)          
  (3) counts로 개수를 세서 자리를 잡아준 뒤, 각 숫자를 자리에 맞게 삽입        

- 의사코드        

```python
counts = [0] * k+1 (data 원소의 범위) #counts배열 초기화 / counts의 크기는 data 개수가 아닌 범위!
# (1) data에서 각 항목의 발생 회수 세기 -> counts에 저장
for i : 0 -> N-1          # 순회
    counts[data[i]] ++     #i가 나올때마다 counts의 i번째 인덱스의 값 1씩 증가 
    
# (2) 누적 반영   
for i : 1 -> k (원소 최대값)
    counts[i] = count[i-1] + counts[i]     
    
# (3) 각 숫자를 자리에 맞게 삽입
for i in range(len(temp)-1, -1, -1):   # 뒤에서부터 순회
    temp[counts[data[i]]-1] = data[i]    
    
# temp(최종배열)의 [counts의 i번째 인덱스의 값(현재까지 누적) -1] 번째 인덱스에는 무조건 i 가 있을 테니까 그 자리에 i 삽입 
# -> 인덱스는 0포함이므로 -1    

    counts[data[i]] -= 1   # 값을 삽입했으니 누적값 하나 감소    
    
# '만약 1의 누적값이 5였다면, 1보다 작은 수를 모두 포함해서 5라는 의미니까 정렬했을 때, 
# 5번째 자리에는 무조건 1이 있을 것이다.' 라는 아이디어에서 착안한 것  

```
</br>      

### 3. 그리디 알고리즘        
###### 알고리즘의 분류 중 하나로, 최적해를 구하는 데 사용하는 근시안적 방법     
- 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해나가는 방식     
- 각 선택은 최적이지만, 그 선택들을 수집하여 결정된 최종 해답이 최적이란 보장은 X              
- 과정     
  1. 현재 상태에서 부분 문제의 최적 해 구하기 -> 부분해 집합에 추가       
  2. 새로운 부분해 집합이 실행가능한지 확인     
  3. 새로운 부분해 집합이 최종 해가 되는 지 확인 -> 아니라면 1부터 다시 시작          
``` 
ex> 거스름돈 문제 해결            
1. 가장 큰 단위의 거스름돈으로 모두 해결하려고 시도    
2. 문제의 제약 사항에 1번 방법이 해당되는지 확인    
3. 거스름돈을 1번 방법으로 모두 거슬러줄 수 있는지 확인 -> 오버하거나 부족하다면 1번으로 돌아가서 다시 생각    
4. 1번으로 돌아가서, 현재 선택한 단위의 거스름돈을 1개 줄이고, 한 단계 아래 단위의 거스름돈으로 나머지 해결 시도    
5. 반복    
``` 
-> 그 외에도 강의실 배정 문제 등등 여러 분야에서 사용된다.    

</br>    

 ### 알고리즘의 효율성 표기법(= 시간 복잡도)              
 ###### ※ 실행 시간 = 프로그램이나 알고리즘이 동작하는 데 걸리는 시간, 몇 초 혹은 몇 번의 계산 과정이 필요한지를 뜻함     
 ###### 괄호 안 = 실행시간 / 아래로 갈수록 더 빠른 알고리즘      
  - 1억번 연산 -> 약 10초 / 10억번 연산 -> 약 1초 소요         
 #### 2-1. 빅 오 표기법(Big-O)     
 ##### 알고리즘을 수행하는 데 필요한 시간의 상한선 의미 = 최악의 경우를 따지는 표기법      
 - 가장 큰 영향력을 주는 n에 대한 항만 표시, 계수 생략            
 
 1. O(n^2) = 버블 정렬, 선택 정렬         
 2. O(n log n) = 병합 정렬     
 3. O(n) = 선형 검색, 이진 탐색(연결 리스트)           
 4. O(log n) = 이진 탐색(배열)     
 5. O(1)     

-> 크기가 어마어마하게 크다면 2로 나누는 것 정도는 티가 안날 것이므로 O(n) = O(n/2)로 취급하며, O(log n)도 밑은 신경 X      
     

#### 2-2. Big-Ω    
##### 알고리즘을 수행하는 데 필요한 시간의 하한선 의미   
1. Ω(n^2) = 선택 정렬        
2. Ω(n log n) = 병합 정렬     
3. Ω(n) = 버블 정렬           
4. Ω(log n)   
5. Ω(1) = 선형 검색, 이진 탐색 -> 운이 좋다면 1번에 바로 찾을 수 있으므로.       

###### ※ O(n) = Ω(n) 인 예시 = 총 갯수 세기. 최선의 방법으로 세더라도 모두 확인하는 수 밖에 없으므로.         


#### 2-3. Big-Θ   
##### 알고리즘 수행 시간의 상한선(O)과 하한선(Ω)이 같은 알고리즘   
1. Θ(n^2) = 선택 정렬   
2. Θ(n log n) = 병합 정렬   
3. Θ(n)    
4. Θ(log n)     
5. Θ(1)    
6.    

</br>   

### 재귀(=Recursion)      
##### 재귀적 정의 : 눈에 보이는 물체의 구조나 가상의 물체의 구조를 해당 물체 자체를 이용해서 설명하는 것 / 단, 시작점은 특별한 경우이므로 아무것도 하지 않고, 재귀적으로 자기 자신을 호출하지 않도록 알려줘야 한다.        
```
void draw(int h);

int main(void)
{
    int height = get_int("Height: ");
    draw(height);
}

void draw(int h)
{
    if (h == 0) // 자기 자신을 무한 호출하는 경우를 막는, 호출을 멈추는 조건문   
    {
        return;
    }

    draw(h - 1);  // h - 1 를 함수에 입력하여 실행    
    
    for (int i = 0; i < h; i++) // h-1 을 입력하여 나온 결과값에 더할 실행 내용     
    {
        printf("#");     
    }
    printf("\n");
}
```   
-> 이렇게 재귀 개념을 사용하면 중첩 루프를 돌지 않아도 스스로를 계속 호출하여 동일한 작업을 반복할 수 있다.   
  



