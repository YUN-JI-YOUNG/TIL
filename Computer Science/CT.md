## - 정보의 표현   
##### 컴퓨터는 2진법, 즉 0과 1로만 모든 데이터를 표현한다.    
HW적으로 표현하자면, 컴퓨터 안의 무수히 많은 작은 트랜지스터들의 스위치를 on = 1, off = 0 으로 표현하는 것이다.  
2진법의 자릿수 하나를 비트(bit)라고 하며, 알파벳 하나를 표현하기 위해선 1바이트(byte) = 8bit가 필요하다.
</br>
1. 숫자 : 10진법으로 표현된 숫자 -> 2진법으로 바꾸어 표현   
2. 문자 : 옛날에 사람들끼리 약속한 ASCII(아스키 코드)에 의해 10진법으로 표현한 후 2진법으로 변환.   
ex. A = 65, H = 72 등
3. 색 : RGB체계 이용 ,해당 색을 분석하여 Red 얼마만큼 + Green 얼마만큼 + Blue 얼마만큼 으로 표현한 후 2진법으로 변환
4. 사진 : 색을 가진 점들이 무수히 많이 찍힌 집합
5. 영상 : 무수히 많은 사진이 빠르게 지나가서 눈의 착시로 움직인다고 생각
6. 음악 : 음, 길이, 음량의 3가지 정보로 표현   
</br>  
ASCII는 미국에서 만든 코드이므로 미국식 영어에 편향되어 있고 당시의 8bit만 표현 가능하여 많은 문자열을 표현하기에 충분하지 않음.   </br>
-> 그래서 ASCII의 상위 집합 유니코드 등장     </br>  
-> 유니코드는 8bit, 16bit, 24bit, 32bit까지도 사용가능하므로 이모티콘 등 많은 문자열 표현 가능.      


</br>        


## - 논리와 증명    
###### ※ 직관은 논리적인 느낌을 주는 것이며, 정확하진 않고 기분상의 강한 착각을 일으키기 때문에 프로그래밍에선 지양해야 한다.       
### - 논리   
1. Soft Logic (일상생활 사용)    
- '초콜릿 몇 개 먹었는지'와 '500원 있는지'는 같은 표현을 사용하지만,    
정확한 갯수를 묻고 있다는 것과 500원 이상 있는지 묻고 있는 것이라는 점에서 의미는 다르다.    
**하지만,** 논리적으로 생각하지 않더라도 어떤 의미인지 모든 사람이 이미 알고 있다.   
- 그렇기 때문에 일상생활에선 Soft Logic이 빨라서 유용하다.    

2. Hard Logic (프로그래밍 사용)     
- 프로그래밍 언어의 표현들은 모두 논리학에서 나온 것이므로 수많은 알고리즘을 이해하기 위해선 Hard Logic이 필요하다.   
- 그래서 알고리즘을 Soft Logic으로 이해하려고 하면 어렵다.   
- 알고리즘 설명이 이해가 안되면 즘영을 봐야 한다. 만약, 증명을 봐도 이해가 안된다면 직관으로 이해하려고 하기 때문이므로 논리적으로 다시 접근해야 한다.     

#### -명제-   
'내가 복권에 당첨되면, 자동차를 산다.' 라는 명제에서     
   
(1)-1. P 거짓 Q 참    
복권에 당첨되지 않았는데 자동차를 샀다. (약속 어기지 않음)    
(1)-2. P 거짓 Q 거짓     
복권에 당첨되지 않았는데 자동차를 사지 않았다. (약속 어기지 않음)   
(2)-1. P 참 Q 거짓   
복권에 당첨되었는데 자동차를 사지 않았다. (약속 어김)   
(2)-2. P 참 Q 참   
복권에 당첨되었는데 자동차를 샀다. (약속 어기지 않음)   
   
- 역 : 자동차를 산다면, 복권에 당첨된다. (Q이면 P이다)     
- 이 : 복권에 당첨되지 않는다면, 자동차를 사지 않는다. (~P이면 ~Q이다)     
- 대우 : 자동차를 사지 않는다면, 복권에 당첨되지 않는다. (~Q이면 ~P이다)      
      
※ 진리표 설명         
- 가정 P가 거짓이면, 결론 Q의 참/거짓 여부에 상관없이 명제는 항상 참이다.     
- 결론 Q가 참이면, 가정 P의 참/거짓 여부에 상관없이 명제는 항상 참이다.   
- 논리곱 ∧은 P and Q 이며, 둘 중 하나라도 거짓이면 거짓이다.    
- 논리합 ∨은 P or Q이며, 둘 다 거짓이면 거짓이다.      

### - 증명   
###### 정확한 명제식으로 표현할 수 있는 것. 즉, 명제식까지 쓰지 않더라도 근본적으론 명제식으로 표현할 수 있어야 한다.   

#### 수학적 귀납법   
- 기본형 : P(1)이 참이고 P(N)->P(N+1)이 참이면 P(N)은 모든 N에 대하여 참이다.   
- 강한 형태 : P(1)이 참이고 P(1)∧P(2)∧...∧P(N) -> P(N+1)이 참이면 P(N)은 모든 N에 대하여 참이다.   



</br>   


## - 알고리즘   
##### 입력(input)에서 받은 자료를 출력(output)형태로 만드는 **처리 과정**
문제 해결의 관점에서의 알고리즘 -> 문제를 해결하는 단계적 방법, 규칙들의 순서적 나열   
직관, 생각을 기계가 이해할 수 있도록 번역하는 것이라고 할 수 있다.    

<1,024 까지의 숫자 중 원하는 수 하나를 찾는 문제>   
1. 가장 무식한 방법은 하나하나 살피는 것 -> 1,024단계 필요   
2. 두 번째로 무식한 방법은 두 개씩 넘겨서 찾는것 -> 512단계 필요
3. 가장 효율적인 방법은 반 씩 나눠 찾는것,    
즉 1부터 512, 513부터 1,024까지 중 원하는 숫자가 포함된 범위만 남기고 나머진 버리는 형식(**분할 정복**) -> 10단계 필요   

알고리즘을 평가하는 요인 : 정확성, 효율성   
-> 1번 알고리즘은 효율성이 떨어진다 / 2번 알고리즘은 정확성이 떨어진다 etc   

문제의 크기 대비 걸리는 시간(효율성) 그래프    
-> 1번 n   / 2번 n/2    / 3번 logn   
</br>   
## - 의사코드   
###### 생각과 직관을 영어 혹은 다른 언어로 정리한 코드와 비슷한 구문   
ex> 친구와 1부터 100까지 숫자 중 1가지 숫자를 맞추는 스무고개 게임을 하려고 한다. 이 때 사용할 알고리즘을 의사코드로 표현하기  

          1. 친구가 숫자 하나를 고른다.
          2. 범위 값 중 중간값을 말한다.
          3. IF 말한 값이 정답과 같다면
             나의 승리로 게임 종료를 선언한다.
          4. Else if 말한 값이 정답보다 작다면
                     말한 값을 시작 값으로 범위를 재설정한다.
                     2번으로 돌아간다.
          5. Else if 말한 값이 정답보다 크다면
                     말한 값을 끝 값으로 범위를 재설정한다.
                     2번으로 돌아간다.
          6. Else If 2번으로 돌아간 횟수가 20번을 초과한다면
                     나의 패배로 게임 종료를 선언한다.
          7. Quit
    
이러한 의사코드와 프로그래밍 언어에는 특정한 건설법 (절차적 프로그래밍)이 존재하므로 몇가지 공통점이 있다.        
   </br>   
1. 함수 (funtions)        </br>   
컴퓨터에게 뭘 할지 알려주는 동사   (ex. 고른다 / 말한다 )   </br>      </br>   
2. 조건 (conditions)        </br>   
나뭇가지나 일종의 갈림길 같은 여러 선택지 중 하나를 고르는 것 (ex. IF / Else if )     </br>      </br>   
3. 불리언 표현 (Boolean expressions)         </br>   
조건 뒤에 나오는, 결정을 내리기 위한 질문 = 예/아니오 or True/Flase or 2진법 1/0으로 답이 나오는 질문 (ex. 말한 값이 뭐뭐 하다면)   </br>      </br>   
4. 루프 (loops)        </br>   
뭔가를 계속해서 반복하는 순환 (ex. 2번으로 돌아간다)        
</br>    

#### ※ 스크래치  
###### MIT의 미디어 랩에서 만든 그래픽 언어     

</br>   


## -- 코드의 디자인   
##### 1. 코드의 정확성   
코드의 동작 여부 점검을 위해 테스트를 작성하여 정확성을 판별한다.    
코드의 작성만큼이나 테스트를 만드는 것은 중요하며, 특히 협업하여 기능을 추가할 때 프로그램이 고장나지 않게 하려면 테스트를 통한 꾸준한 점검은 필수이다.   
##### 2. 코드의 가독성 (심미적 부분)   
코드는 수정 및 유지보수할 때를 생각하여 본인과 다른사람이 이해하기 쉽도록 작성해야 한다.    
사람마다 미적 기준은 다르기 때문에, 기업들에서 정한 보기 좋은 코드의 표준이 존재한다.   
</br>    

## -- 컴파일링   
### 컴파일 실행 단계      
#### 1. preprocessing (전처리)    
프로그램이 ```#include <cs50.h>```라는 코드를 cs50.h라는 파일에서 해당되는 코드로 대체하는 등의 작업   
👉 ```#include <cs50.h>``` -> ```... string get_string(string prompt);  ...```
#### 2. compiling (컴파일링)    
전처리한 소스코드를 중간단계인 어셈블리 코드로 바꾸는 작업   

#### 3. assembling (어셈블링)   
컴파일링한 어셈블리 코드를 0과 1로 이루어진 머신코드로 바꾸는 작업   

#### 4. linking (링크)     
###### (라이브러리를 포함해서 여러 개의 파일로 이루어져있을 때만 추가되는 단계)
원 파일을 포함하여 연관된 파일(라이브러리)들의 모든 머신 코드를 하나의 큰 파일로 합치는 작업    
</br>  

## -- 디버깅   
#### 버그의 원인을 찾아내어 수정하는 작업 / valgrind 등의 디버깅 도구 사용 [``` valgrind ./(파일명) ```]        
#### 1. 문법적 오류   
에러 메세지를 통해 버그의 원인을 찾고 고쳐나간다.   
#### 2. 논리적 오류   
행의 왼쪽을 눌러 중지점을 찍고, 디버거를 실행하여 중지점에서 프로그램 실행이 멈추면 단계별로 실행하며    
버그의 원인이 무엇인지 찾아내어 수정한다.   
###### 버그 : 문법적 오류와 논리적 오류를 포함한, 프로그래머가 의도하지 않은 오류    
###### 중지점 : Eclipse, NetBeans, Visula Studio등 대부분의 IDE(통합 개발환경)에 존재하며, 프로그램을 실행할 때 디버깅을 위해 멈추는 지점    
###### 디버거 : 중지점에서부터 프로그램을 단계별로 실행할 수 있게 하여 버그의 식별과 수정을 용이하게 한다. 
###### 　　　　Ctrl + C를 누르면 디버거 프로그램창에서 터미널 창으로 다시 돌아온다.      
</br>     



