## 2차원 배열

###### 1차원 List를 묶어놓은 List이며, 2차원 이상의 다차원 리스트(사용이 많진 않음)는 차원에 따라 인덱스를 선언     

- 선언    

  - 세로(행의 개수) x 가로(열의 개수) 필요     

  ```python
  N, M = map(int, input().split())
  arr = [list(map(int, input().split())) for _ in range(N)]
  # 단순 반복은 for _ in 처럼 표현할 수 있음     
  ```

  ```python
  arr2 = [[0]*M]*N  # 사용불가
  # arr2[0] 과 arr2[1] ... 얕은 복사가 되어 모든 배열 내의 요소가 다함께 변경된다.
  # = 1행의 리스트의 id 객체를 모두 같이 공유
  ```

- 배열 순회  (인덱스 연산)       

  - 행 우선 순회    

  ```python
  for i in range(len(arr)):  # 행 순회
      for j in range(len(arr[i]))  # 열 순회
  # 특별히 제약이 없다면 기본적으론 행 우선 순회
  # 보통은 문제에서 나온대로 사용하고 len(arr) 등을 사용하진 않는다.
  ```

  - 열 우선 순회

  ```python
  for j in range(len(arr[i])):
      for i in range(len(arr))
      
  # 각 열의 합 중 최대값 구하기 등의 특별한 경우에 사용
  ```

  - 지그재그 순회

  ```python
  for i in range(len(arr)):  
      for j in range(len(arr[i]))  :
          arr[i][j + (m-1-2*j) * (i %2)]
  # 짝수행이면 j : 0 -> M-1
  # 홀수행이면 j : M-1 -> 0
  # 짝수행 끝과 홀수행 끝의 차이가 M-1-j이므로 j + ( ) = M-1-j 이 되어야 해서 ( ) = M-1-2*j
  # 짝수면 i % 2 가 0이므로 ok
  
  #디지털 이미지 처리 및 필터링 등의 작업을 할 때, 대각선으로 지그재그 순회해야할 때가 있음
  ```

  - 델타 이용 탐색     

  ```python
  arr[0..n-1][0..n-1]
  di[] = [0,0,-1,1]
  dj[] = [-1,1,0,0]
        # 좌 우 상 하 / d = (i+0, j-1), (i+0,j+1),(i-1,j+0),(i+1,j+0) 이므로
      # 방향전환용이므로 현재 코드가 어떻게 방향 전환하는지 잘 생각하기
      # i는 행이니까 상(-1), 하(+1), j는 열이니까 좌(-1), 우(+1)
  for i in range(len(arr)):  # 행
      for j in range(len(arr[x])): # 열  
          for k in ragne(4):     # 만약 대각선까지 8방향을 한다면 범위가 8
              ni = i + di[k]
              nj = j + dj[k]
              if 0 <= ni < N and 0 <=nj <= M:  #인덱스 에러 방지
                  arr[ni][nj]
              
  for i in range(len(arr)):
      for j in range(len(arr[x])): 
          for dx, dy in [[0,1],[1,0],[0,-1],[-1,0]]:
              ni = i + dx
              nj = j + dy
              if 0 <= ni < N and 0 <=nj <= M: 
                  arr[ni][nj]
  
  ```

  - 전치 행렬     
    - 대각선(왼쪽 위-> 오른쪽 아래)을 기준으로 대치되는 지점끼리 바뀌는 것

  ```python
  arr = [[1,2,3],[4,5,6],[7,8,9]] 
  
  for i in range(3):
      for j in range(3):
          if i < j :
              arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
              
  # 대각선 (왼쪽 아래 -> 오른쪽 위)
  왼쪽 윗부분 : i < N-1-j
  오른쪽 아래 : i > N-1-j
      
  # + 모양으로 나눌 경우 (| 가 i, -가 j)
  왼쪽 윗부분 : x<i, y<j
  오른쪽 윗부분 : x<i, y>j
  왼쪽 아래 : x>i, y<j
  오른쪽 아래 : x<i, y<i
  ```

</br>     

## 부분집합 합 문제

###### 유한 개의 정수로 이루어진 집합의 부분 집합 중, 그 집합의 원소 합이 0이 되는 경우를 찾는 문제

- 완전 검색 기법

  - 모든 부분집합 생성한 후, 합 구하기
    - 집합 원소가 n이면 부분집합의 개수는 2^n개    

  ```python
  bit = [0,0,0,0]
  for i in ragne(2):
      bit[0] = i
      for j in range(2):
          bit[1] = j
          for k in range(2):
              bit[2] = k
              for l in range(2):
                  bit[3] = l
                  print(bit) # 생성된 부분집합 출력
  
  # 어떤 집합 A에 대해서
  for p in range(4):
      if bit[p]:
          print(A[p], end=' ') 
          # 부분집합의 인덱스 출력, [0,0,0,1] = 4 출력, [0,0,1,1] = 3 4 출력 
          # 공집합은 빈 줄
          # 여기서 합을 구하면 부분집합 합
  print()  #  모든 부분집합 인덱스 출력 가능 
  ```

</br>     

## 비트 연산자

###### 비트 단위의 조작이 가능하게 하는 연산      

```python
# 더 간단하게 부분집합 생성
n = len(arr)
for i in range(1<<n):  # 공집합 제외하기 위해선 (1, 1<<n) 범위   
    for j in range(n):  # 원소 수만큼 비트 비교 , j =비트 개수
        if i & (1<<j) : # i의 j번째 비트가 1이면
            # true인 i와 and 연산이므로 1<<j에 따라 T/F 결정 
            # 처음엔 i =0, j= 0 이므로 i = 0 0 0 0 0 0 , 1<<j = 0 0 0 0 0 1 이라서 패스, i = 1, j =0 이면 0 0 0 0 0 1 / 0 0 0 0 0 1 이므로 1출력 -> arr[0] 출력
            # 1에서 j만큼 시프트했는데 1이 존재한다면 True
            # 즉 i의 j번째 비트가 1인 값 찾기    
            print(arr[j], end=' ') # j번째 원소 출력
```

- << 연산자     
  - 비트가 왼쪽으로 하나 이동한다는 것은 `x 2` 의미    
  - `1 << n = 2^n` 즉, 원소가 n개일 경우의 모든 부분집합의 수     
- ^ 연산자
  - 두 비트가 서로 다를때 `1` 반환 
- `&` : and 
  - 특정 비트를 0으로 만드는 연산으로 활용    
  - i의 j번 비트 검사 : `i & (1 << j)`  -> j가 0이면 i의 0번 비트가 1
- `|` : or
  - 특정 비트를 1로 만드는 연산으로 활용
- `~` : not 

</br>     

## 인덱스

###### DB에서 유래했으며, 테이블에 대한 동작 속도를 높여주는 자료 구조.  

###### DB 분야가 아니면 Look up table 등의 용어를 사용하기도 한다.              

- 저장하는데 필요한 디스크 공간 : 인덱스 < 테이블     

  - 인덱스는 다른 세부 항목 없이 `키-필드` 만 갖고 있기 때문.     

- 배열을 사용한 인덱스   

  - 대량의 데이터를 매번 정렬하면 반응이 느려지기 때문에 이러한 문제를 해결하기 위해 배열 인덱스 사용 가능      

    - 만약 이름을 기준으로 정렬한다면, 원본 데이터를 정렬하는 것이 아니라 이름을 정렬한 다음, `원본 데이터`에서 `해당 이름에 대한 값의 인덱스`를 찾아서 `정렬된 배열`에 `추가` 

      -> 훨씬 빠른 속도     

