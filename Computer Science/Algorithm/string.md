## String

- 각 문자에 대응되는 숫자를 정해서 그 숫자를 메모리에 저장      

- 영어 대소문자는 총 52개이므로 6비트 (=2^6) 로 모두 표현 가능  = 코드 체계     

  - ASCII = 문자 인코딩 표준안     
    - 초기엔 제조 회사 등에 따라 각각의 코드 체계 보유    
    - 하지만 네크워크가 발전하면서 서로 정보해석이 다르다는 문제 발생         
    - 이러한 혼동을 피하기 위해 만듦      
      - ASCII 는 7-bit 인코딩이며 128문자를 표현    
        - 출력 불가능 33개 - 줄바꿈 등     
        - 출력 가능 95개 - 빈칸 포함          
      - 확장 ASCII     
        - 표준 문자 이외의 부가적인 문자를 128개 추가 가능하게 하는 부호     
          - 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 
        - 1Byte 내의 8bits를 모두 사용       
        - 표준 아스키와 달라 서로 다른 프로그램이나 컴퓨터 사이에서 교환되지 못함      
        - 일반적으론 해독할 수 있도록 설계된 프로그램이나 프린터, 컴퓨터만 해독 가능    
  - 유니코드 = 다국어 처리를 위한 표준 코드 체계      
    - 컴퓨터가 발전하면서 각 국가들이 ASCII 형식으로 자국의 문자를 표현하기 위한 코드체계 만들어 사용    
    - 국가 간 정보 주고받을 때, 해당 코드체계가 없으면 잘못 해석할 가능성이 존재하여 이를 방지하기 위해 만듦       
    - Character Set로 분류     
      - UCS-2 / UCS-4    
      - 유니코드를 저장하는 변수의 크기 정의
      - 바이트 순서에 대해선 표준화하지 못해서 UCS-2 와 UCS-4 를 구분해서 다르게 구현해야 하는 문제 발생 -> 외부 인코딩 필요    
        - big-endian, little-endian  
        - 유니코드 인코딩 (UTF)
          - UTF - 8 (web)
            - 8bits ~ 32bits (1 byte * 4)
          - UTF - 16 (windows, java)
            - 16bits ~ 32bits (2 byte * 2)
          - UTF - 32 (unix)
            - 32bits ~ 32bits (4 byte * 1)
          - python 2.x 버전 : `#-*- coding: utf-8 -*- ` 첫 줄 명시 필요    
            - 3.x 버전 : 생략 가능    
            - 다른 인코딩 방식 처리시 첫줄에 위의 코드를 형식에 맞춰 작성     

- 문자열         

  - 분류      
    - fixed length      
    - variable length    
      - length controlled (자바) - 글자수로 관리
      - delimited (C) - 널문자로 종료 표시하여 관리     
    - java.lang.String 클래스에 대한 메모리 배치         
      - 기본적인 객체 메타 데이터 + hash, count(문자열 길이), offset(문자열 시작점), value(문자열 배열에 대한 참조 class pointer -> Falgs, Locks, size, char[])
  - C언어 문자열 처리    
    - 문자들의 배열 형태로 구현된 응용 자료형     
    - 항상 마지막에 종료 표시하는 널문자(`\0`) 필요    
    - 문자열 처리에 필요한 연산을 함수 형태로 제공    
  - Java (객체 지향 언어) 문자열 처리    
    - 문자열 데이터 저장, 처리해주는 String클래스 제공    
      - `String str="abs"`  `String str = new String("abs")` 
    - 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공    
      - 보다 풍부한 연산 제공      
  - python 문자열 처리      
    - char 타입 X    
    - 텍스트 데이터 취급 방법 통일 
      - 반복 - `'a'* 10`  , 연결 - `'a' + 'b'` 등  
    - 시퀀스 자료형으로 분류되며 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산 등 사용 가능 -  `replace(), split(), isalpha(), find()` 등 
    - **immutable** ( 요소값 수정 불가능) 
      - 인덱싱 연산 가능하다고 해서 수정 가능하다는 것은 X      
  - C 와 java, python 문자열 처리 차이점      
    - c = 아스키 코드로 저장   
      - 문자열 길이 출력할 때 실제 메모리 사용 수 출력     
    - java = 유니코드`UTF-16(2 byte)` / python = 유니코드`UTF-8`로 저장    
      - 문자열 길이 출력할 때 실제 문자열 길이 출력      

- 문자열 뒤집기     

  ​		(1) 원본을 뒤집는 방법       

  ​			- swap을 위한 임시 변수 필요

  ​			- 문자열 길이의 반만큼 반복 수행 필요 `n//2`         

  ​		(2) 새로운 빈 문자열 생성 후 뒤에서부터 읽어 쓰는 방법            

  - C 언어
    - swap을 위한 임시 변수 필요  (swap - `s[i] <-> s[n-1-i]` )
  - java
    -  `StringBuffer 클래스의 reverse()` 메소드  이용
  - python
    -  `Reverse 함수 ` or 슬라이싱 이용     

- 문자열 비교    

  - C 언어

    - strcmp() 함수 제공   

  - java   

    - `equals()` 메소드 제공     
    - `==` 연산은 메모리 참조가 같은지 비교하는 것이므로 문자열 비교 X     

  - python    

    - `==` 연산자, `is` 연산자     

    - `==` 연산자는 내부적으로 특수 메소드 `__eq__()` 호출    

    - `==` 연산자는 모양,내용이 같은지 여부, `is` 연산자는 같은 객체인지 여부 판단이므로     

      `a == '123' ` , `a is b` 는 True 지만, `a is '123'`는 False     

      -> 잘 판단하여 사용          

- 문자열 숫자 -> 정수 변환     

  - C 언어    
    - `atoi()` 함수 제공     
    - 역함수로  `itoa()` 함수 제공     
  - java     
    - 숫자 클래스의 `parse` 메소드 제공    
    - 역함수로  `toString()` 메소드 제공     
  - python     
    - 숫자, 문자 변환 함수 제공 `int()`  , `str()` ,  `float()` , `repr()`    

- 문자열 암호화     

  - 시저 암호    
  - 문자 변환표를 이용한 암호화(단일 치환 암호)      
    - 튜링 머신(최초의 컴퓨터)         
    - 복호화 하기 위해선 모든 키의 조합 필요 -> 키는 총 26! 개 존재         
    - 1초에 10억개의 키를 적용하더라도 120억년 이상의 시간 소요     
  - bit열의 암호화    
    - 배타적 논리합( `or`) 연산 사용   

- 문자열 압축   

  - Run-length encoding 알고리즘    
    - 반복 있을 것이라 가정 -> 같은 값이 몇 번 반복되는가를 나타냄으로써 압축       
      - ABBCCC -> A1B2C3 같은 방법     
    - bmp 파일포맷의 압축 방법     
    - 만약 운이 안좋다면 A1B1C1 같은 식이 되어 그냥 길이만 2배가 될 수도 있음     
  - 많이 사용하는 알고리즘 : 허프만 코딩 알고리즘         

</br>    

## 패턴매칭

[실제 구현과정 디버깅](http://whocouldthat.be/visualizing-string-matching/) 

1. 고지식한 패턴 검색 알고리즘     

   - 인덱스 연산 연습   

   - 본문 문자열(t)을 처음부터 끝까지 차례대로 순회하면서 패턴(p) 내의 문자들을 일일이 비교    

   - 실패한다면 실패한 부분에서 한칸 이동하고 p는 원점으로 돌려서 다시 비교     

     ```python
     if t[i] != p[j]: # 비교 실패
         #1 이동시키는 코드는 새로 짜거나 for문 돌려야함
         # i -> 0 ~ (len(t) - len(p))
         # j -> 0 ~ M-1
         i = i-j+1 # 비교한 위치 다음 부터 다시 시작
         j = 0
         
         #2 매번 한칸씩 이동시키는 코드 - while문 가능 (인덱스 범위 조건 설정 가능)
         i = i-j  # 이전 비교 끝난 위치
         j = -1
     i = i+1 # 이전 비교 다음 위치
     j = j+1
     
     	# 3 시작 위치 고정하고 패턴길이만큼 이동
         if p[j] != t[i+j]:
             break
         if j == len(p)-1:
         	return
     ```

   - j == len(p)-1 라면 검색 성공

   - 최악의 경우 텍스트의 모든 위치에서 비교해야하므로 시간복잡도는 O(len(t)*len(p))     

2. 카프-라빈 알고리즘

3. KMP 알고리즘     

   - 불일치가 발생한 텍스트의 앞 부분에 대하여 다시 비교하지 않고 매칭 수행         

   - 즉, 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작 최소화    

     - next[M] = 불일치가 발생했을 경우 이동할 다음 위치     

   - 시간복잡도 O(len(t) + len(p))

   - 고지식한 패턴 검색 알고리즘은 1칸씩만 이동한다면, KMP 알고리즘은 패턴의 각 위치에 대해 실패했을 때 미리 계산해둔 위치로 이동    

     - t[4] 와 p[4] 비교가 실패한다면 t[4]와 p[2] 를 다시 비교  < p의 각 위치에 대해, 실패했을 때  돌아갈 인덱스를 미리 정해둔다는 뜻       
     - [-1, 0, 0, 0, 0, 1, 2, 3, 0] / `p[0] 실패 -> p[-1]부터`, `p[5] 실패 -> p[1]`부터 비교    

     ```python
      next 배열은 일치하는 패턴 길이로 생성 가능, 패턴 a b c d e f 를 찾는다면,
     불일치 = 0
     # 1. 테이블 밀어서 만드는 경우
     # -1 인 경우는 p 인덱스이동이 아니라 t[2]부터 다시 비교 시작한다는 말과 같은 뜻
     next[-1,0,1,2,3,0]  -> 인덱스 2부터가 카운트한 값   
       p   a b c d e f  -> e에서 불일치했으니 인덱스 3, 즉 d로 이동해서 다시 t와 비교
       t   b b c d f ...   
                  d e f ... 로 다시 비교 시작?
     
     # 2. 테이블 밀지 X -> 다시 비교 시작하면 하나 전의 칸에서 불러와야 함
     next[0, 0,1,2,3,0 ]  
        p    a b c d e f  -> e에서 불일치하면 인덱스 0, 즉 a로 이동해서 다시 t와 비교
        t    b b c d f ...  
     ```

     ```python
     # 테이블 밀지 않는 경우의 next 배열 만들기
     cnt = 0 #일치한 개수
     next = [0] * M # M= len(p)
     i = 1
     while i < M :
         if p[i] == p[cnt]:
             cnt += 1
             next[i] = cnt   # 테이블 민다면 next[i+1] = cnt
             i += 1
         else :
             if cnt != 0:  # 앞에서 일치되다가 불일치가 되는 경우
                 cnt = next[cnt-1] 
             # 1,2,3 까지 일치되고 4번째에서 불일치면 next[2]
                 
             else:    # 앞에서 일치된 게 없는 경우
                 next[i] = 0
                 i += 1
     ```

4. 보이어-무어 알고리즘     

- 오른쪽 -> 왼쪽 비교  / 무조건 오른쪽 끝 문자끼리부터 비교  -> 일치하면 그 왼쪽 문자끼리 비교        
- 대부분의 상용 소프트웨어에서 채택중인 알고리즘으로 알려짐   
- 패턴의 오른쪽 끝 문자가 불일치하고, 패턴 내에 없으면 패턴 길이만큼 이동 -> 다시 끝 문자 비교     

```python
t =         b w a t e r ...
p = w a t e r   -> r != b 인데, b가 패턴(p)내에 존재하지도 않으므로 len(p)만큼 이동
t =         b w a t e r ...
p =           w a t e r   
```

- 불일치한 글자가 패턴 내에 존재한다면, 일치하는 문자끼리 맞춰지게끔 이동하고 끝 글자 비교          

- skip 배열 

  ```python
  t =         w a e r e r ...
  p = w a t e r 
  w -> 4 skip 이므로 w는 4.. 이런식으로 a, t, e, r 의 skip 횟수를 기록하고 나머지 문자는 모두 len(p)로 기록한 배열이 skip배열
  ```



### 문자열 매칭 알고리즘 비교    

- len(p) = m , len(t) = n
- 고지식한 패턴 검색 알고리즘 : O(mn)
- 카프-라빈 알고리즘 : Θ(n)
- KMP 알고리즘 : Θ(n)  
  - O(m+n) 이었지만, n이 아주 크면 m 생략하여 표현    
- 보이어-무어 알고리즘 : 
  - 최악의 경우엔 Θ(mn)     
  - 텍스트 문자열을 적어도 한번씩 훑어서 최선의 경우에도 Ω(n)       
  - 일반적으로 Θ(n) 보단 시간이 덜 든다        
  - 문자열에 사용된 문자들 집합이 많을 때 효율 ↑     

