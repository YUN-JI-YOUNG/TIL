### 1. 검색 알고리즘       
###### 저장되어 있는 자료 중 원하는 항목을 찾는 작업, 목적하는 탐색 키를 가진 항목 찾기         
-  탐색 키     
   - 자료를 구별하여 인식할 수 있는 키     
#### 1-1. 선형 탐색(=linear search, 순차 검색)      
##### 일렬로 구성된 자료(배열)의 인덱스를 처음부터 하나씩 증가시키면서 탐색하는 가장 간단하고 직관적인 검색 방법           
###### - 효율성 : O(n), Ω(1)     
- 배열, 연결리스트 등 순차 구조로 구현된 자료구조에서 유용      
- 검색 대상의 수가 많으면 수행시간이 급증하여 비효율      

- 정렬 X    
  - 첫번째 원소부터 순서대로 같은 원소가 있는지 비교하며 찾고, 찾으면 해당 인덱스 반환 -> 마지막까지 못 찾으면 실패    
    (**인덱스 오류 방지 위해 인덱스 검사 먼저!** / 실패하면 -1 리턴)  
    `i < n and a[i] !=key` 는 단축평가로, 인덱스 검사가 True 여야 다음 조건 검사      
  - 찾고자 하는 원소의 순서에 따라 회수 결정         
  - 평균 비교 회수는 (1/n) * (1+2+...+n) = (n+1)/2 이므로 시간 복잡도 O(n)       
   
- 정렬 O    
  - 자료를 순차적으로 검색하며 키 값 검색 -> 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 종료 = 즉, 10을 찾는데 12를 먼저 찾는다면 종료      
  - 시간복잡도 O(n)          
  - while 종료조건 = `공통 : i < n`,  `정렬X : a[i] != key` , `정렬O : a[i] < key`        


의사코드 예시 >   
``` 
for i from 0 to n-1    
　if i번째 요소 = 50   
  　　return true   
return false      
``` 

실제코드 예시(C언어) >   
```
int main(void)   
{ 
　int numbers[]={1,4,6,3,18,2,50};   
　
 for(int i = 0; i<7; i++)
{
  if(numbers[i]==50)   
    {
      printf("Found\n");
      return 0;
    }
 }
 printf("Not Found\n");
 return 1;
}
```

</br>


#### 1-2. 이진 탐색(=binary serach)      
##### 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 범위를 결정하고 진행하는 방법        
###### - 효율성 : O(log n), Ω(1)      
ex) 분할 정복 기법       

- 검색 범위를 반으로 줄여가면서(log로 줄어듦) 보다 빠르게 검색 수행 가능         
- 반드시 **정렬된 자료**만 가능   
  - 중앙에 있는 원소 선택(보통 `(i + j) //2` 인덱스 선택) 후 목표와 비교     
  - 목표보다 중앙값이 작으면, 오른쪽 반에 대해 검색 수행 (start = middle + 1)   
  - 목표보다 중앙값이 크다면, 왼쪽 반에 대해 검색 수행 (end = middle -1)   
  - 줄어든 범위에서 다시 중앙값 선택 후 반복        
    -> 재귀함수 이용할 수도 있음, but 실행 속도는 반복구조가 더 빠름       
- 자료에 삽입 or 삭제가 발생하면 다시 정렬하는 추가 작업 필요       
- while 종료 조건 = `start <= end` (즉, 검색 범위가 존재할 때)   


의사코드 예시 >  
```
if no items  
　return false      
if middle item = 50     
　return true   
if middle item > 50   
　search left half    
if middle item <50    
　search right half   
 ```
 
 </br>     
 
 #### 1-3. 해쉬      
 </br>     
 
 ### 2. 정렬 알고리즘    
 #### 2-1. 버블 정렬(=bubble sort)            
 ##### 큰 숫자가 올바른 위치로 갈 때까지 움직이는 정렬 방법       
 의사코드 예시1 >   효율성 : O(n^2), Ω(n^2)   
 ```
 Repeat n-1    
 　For i from 0 to n-2   
   　　If i'th and i+1'th elements out of order       
 　Swap them     
  ```
 -> 바깥쪽 반복문은 최대 n-1번 실행, 안쪽 반복문도 최대 n-1번 실행(0 to n-2)이므로 (n-1) x (n-1) = n^2+2n+1 = O(n^2)   
 -> n의 값이 커질수록 n^2의 영향력이 커지므로    
    
 의사코드 예시2 > 효율성 : O(n^2), Ω(n)   
 ```
 Repeat until no swaps   
 　For i from 0 to n-2   
  　If i'th and i+1'th elements out of order   
   Swap them   
   ```
 -> 만약 정렬이 되어있다면 n-1쌍을 모두 확인하여 swap이 일어나지 않으면 종료하니까 하한이 n-1이므로 = Ω(n)   
 
 </br>   
 
 #### 2-2. 선택 정렬(=selection sort)      
 ##### 가장 작은 값을 찾아 1번째 숫자와 바꾸고, 그 다음 작은 값을 찾아 2번째의 숫자와 바꾸는 것을 반복하는 정렬 방법   
 ###### - 효율성 : O(n^2), Ω(n^2)       
 
 의사코드 예시 >     
```
Repeat n       
 　For i from 0 to n-1   
 　　Find smallest item between i'th item and last item   
  　Swap smallest item with i'th item      
   ```
 -> 제일 적은 숫자를 찾는데 n번, 그 다음 작은 숫자 찾는데 n-1번...이므로 n+(n-1)+(n-2)+...+1 = n(n+1)/2 = (n^2)/2 + n/2 = O(n^2)        
 
- 과정      
   - 리스트 중 최소값 찾기    
   - 해당 값을 리스트 맨 앞의 값과 교환    
   - 나머지 구간에 대해 위의 과정 반복     
```python
for i in range(n-1):     # 작업구간의 시작
    min = i
    for j in range(i+1, n):  # 최소값 찾을 구간 # 구간의 시작이 줄어든다
        if a[min] > a[j]:    # 최소값 찾기
            min = j
    a[i], a[min] = a[min],a[i]  # 최소값을 맨 앞으로 교환
```     
   
 </br>   
 
 #### 2-3. 병합 정렬=(merge sort)     
 ##### 재귀 알고리즘을 활용한 정렬, 왼쪽 절반을 먼저 정렬하고 오른쪽 절반을 정렬하는데, 배열에 값이 1개이면 그대로 반환하는 정렬 방법             
 
 의사코드 예시>
 ```
 If only one item 
 　Return   
 Else
 　Sort left half of items   
 　Sort right half of items   
 　Merge sorted halves   
 ```    
ex> 2 3 5 1 4 9 8 6 : 왼쪽 절반인 2,3,5,1 정렬 -> 왼쪽 절반 2,3 정렬 -> [왼쪽 절반 2 정렬 -> 반환 -> 오른쪽 절반 3 정렬 -> 반환]   
-> 병합 정렬하면 2 3 으로 정렬 -> 다른 배열도 같은 과정 반복    

 ###### 병합 : 두 배열 중 가장 작은 값을 꺼내 다른 배열의 가장 작은 값 다음에 두는 과정      
 
 -> 무언가를 계속 절반으로 나누는 것을 log 함수로 표현하는데 매 단계마다 n번씩 확인을 총 log n 단계 만큼 하므로 n x log n = O(n log n)   
 
 </br>     
 
 #### 2-4. 카운팅 정렬(=counting sort)    
 ###### 집합에 있는 각 항목의 개수를 세는 작업을 한 후, 선형 시간에 정렬하는 효율적인 알고리즘           
- 비교환 방식    
- 각 항목의 발생 회수를 기록하기 위해 정수 항목으로 인덱스되어야 해서 정수 or 정수로  표현가능한 자료에 대해서만 적용 가능        	   
- 시간 복잡도 : O(n+k) : n은 리스트 길이, k는 정수 최대값        
  - for 문이 각각 돌기 때문            
- n,k가 비교적 작을 때만 가능 (범위n는 작은데 값k가 클 수도 있으므로)        


- 과정     
  (1) data에서 각 항목의 발생 회수 세고, 정수 항목으로 인덱스되는 카운트 배열 counts에 저장       
  (2) 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영 (누적)          
  (3) counts로 개수를 세서 자리를 잡아준 뒤, 각 숫자를 자리에 맞게 삽입        

- 의사코드        

```python
counts = [0] * k+1 (data 원소의 범위) #counts배열 초기화 / counts의 크기는 data 개수가 아닌 범위!
# (1) data에서 각 항목의 발생 회수 세기 -> counts에 저장
for i : 0 -> N-1          # 순회
    counts[data[i]] ++     #i가 나올때마다 counts의 i번째 인덱스의 값 1씩 증가 
    
# (2) 누적 반영   
for i : 1 -> k (원소 최대값)
    counts[i] = count[i-1] + counts[i]     
    
# (3) 각 숫자를 자리에 맞게 삽입
for i in range(len(temp)-1, -1, -1):   # 뒤에서부터 순회
    temp[counts[data[i]]-1] = data[i]    
    
# temp(최종배열)의 [counts의 i번째 인덱스의 값(현재까지 누적) -1] 번째 인덱스에는 무조건 i 가 있을 테니까 그 자리에 i 삽입 
# -> 인덱스는 0포함이므로 -1    

    counts[data[i]] -= 1   # 값을 삽입했으니 누적값 하나 감소    
    
# '만약 1의 누적값이 5였다면, 1보다 작은 수를 모두 포함해서 5라는 의미니까 정렬했을 때, 
# 5번째 자리에는 무조건 1이 있을 것이다.' 라는 아이디어에서 착안한 것  

```
</br>      

#### 2-5. 셀렉션 알고리즘     
###### 저장되어 있는 자료로부터 k번째로 (큰 or 작은) 원소를 찾는 방법          
- 과정   
  - 정렬 알고리즘 이용하여 자료 정렬   
  - 원하는 순서에 있는 원소 가져오기   
- k번째로 작은 원소 찾기    
  - k 번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고 배열의 k번째 반환       
  - 시간복잡도 O(kn)         
    - k가 작을 때 유리. 만약 n과 가깝다면 결국 n^2 이 되므로        
- 선택 정렬과의 차이점   
  - 선택 정렬은 전체 구간   
  - 셀렉션 알고리즘은 특정 구간(1~k)     

</br>    

## 정렬 알고리즘 비교     



| 알고리즘    | 평균 수행시간 | 최악 수행시간 | 기법        | 비고                                       |
| ----------- | ------------- | ------------- | ----------- | ------------------------------------------ |
| 버블정렬    | O(n^2)        | O(n^2)        | 비교, 교환  | 코딩 가장 쉬움                             |
| 카운팅 정렬 | O(n+k)        | O(n+k)        | 비교환 방식 | n이 비교적 작을때만 가능                   |
| 선택 정렬   | O(n^2)        | O(n^2)        | 비교, 교환  | 교환의 횟수 <br />선택 < 버블,삽입정렬     |
| 퀵 정렬     | O(n log n)    | O(n^2)        | 분할 정복   | 최악을 제외하면 <br />평균적으로 가장 빠름 |
| 삽입 정렬   | O(n^2)        | O(n^2)        | 비교, 교환  | n의 개수가 작을때 <br />효과적             |
| 병합 정렬   | O(n log n)    | O(n log n)    | 분할 정복   | 연결리스트의 경우 <br />가장 효율 ↑        |

