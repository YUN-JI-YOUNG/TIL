## 스택

###### 물건을 쌓아올리 듯 자료를 쌓아 올린 형태의 자료구조    

- 구조

  - 선형 구조      

  - 자료 간의 관계가 1 : 1의 관계를 갖는 구조         

- 스택에 자료를 삽입 하거나 꺼낼 수 있다     

- 후입선출(LIFO,  Last-In-First-Out) - 마지막에 삽입한 자료를 가장 먼저 꺼냄     

- 구현    

  - 자료구조 - 자료를 선형으로 저장할 저장소    
    - C언어에서는 배열 사용 가능    
    - 저장소 자체를 스택이라 부르기도 함     
    - 스택에 마지막 삽입된 원소의 위치를 `top`라 부름 (=stack pointer)     
  - 연산     
    - 삽입 - 자료 저장 (push)      
    - 삭제 - 자료를 삽입한 순서의 역순으로 꺼낸다 (pop)       
    - 공백인지 아닌지 확인 - isEmpty  <-> isNotEmpty(= `!isEmpty`)      
    - top에 있는 원소(item)를 확인 - peek      

  ```python
  5 스택 생성 - stack[0] * 5 
  
  push(n) - 
  top += 1
  stack[top] = n
  * 꽉찬 스택에 push할 때의 동작도 필요    
  
  pop(n) - 
  top -= 1
  return stack[top+1]
  * 빈 스택에 pop할 때의 동작도 필요   
  
  # 알고리즘   
  s = []
  def push():
      s.append(item)     
      
  def pop():
      if len(s) == 0:   # -> 이 부분은 디버깅 용도 (보통 공백인지 확인 후 pop하므로)
          # underflow (에러 메세지 작성)    
          return
      else:
          return s.pop(-1);
  
  ```

  - 고려사항    
    - 1차원 배열 사용하면 구현이 용이(`장점`)하지만, 스택의 크기변경이 어렵다(`단점`)       
      - 일반적으로 스택의 크기를 어림짐작하여 구현     
    - 이를 극복하기 위해 저장소를 동적으로 할당하여 스택을 구현하는 방법 존재    
      -  동적 연결리스트를 이용하여 구현     
      -  구현이 복잡(`단점`)하지만, 메모리를 효율적으로 사용한다(`장점`)       

- 응용1 - 괄호 검사  `[`,`]`,`{`,`}`, `(`,`)`       

  - 조건1 - 여는 괄호의 개수와 닫는 괄호의 개수 동일     
  - 조건2 - 같은 괄호에서 여는 괄호는 닫는 괄호보다 먼저 나와야 함    
  - 조건3 - 괄호 사이엔 포함 관계만 존재     
    - 여는 괄호나오면 push     
    - 닫는 괄호나오면 pop 하여 짝 맞는지 비교      
    - `수식이 끝났는데 스택에 무언가 남거나` or `닫는 괄호가 남았는데 빈 스택`  = 오류    

- 응용2 - function call     

  - 프로그램에서의 함수 호출, 복귀에 따른 수행 순서 관리      
    - 가장 마지막에 호출된 함수가 가장 먼저 실행 완료되고 복귀하는 후입선출 구조이므로 스택으로 수행 순서 관리 가능          
    - 과정   
      - 호출한 함수 수행에 필요한 정보를 스택 프레임에 저장하여 시스템 스택에 삽입     
      - 실행 종료 후 시스템 스택의 top(스택 프레임)을 **pop** -> 복귀 주소 확인 후 복귀     
      - 이 과정을 반복하며 전체 수행이 종료되면 시스템 스택은 공백 스택이 된다.     
  - 시스템 스택    
    - 스택 프레임(`__main__`) - > 스택프레임(F_1) -> 스택 프레임(F_2) 순으로 스택에 쌓임     
    - main 함수 실행하던 정보 -> F_1 함수 실행하던 정보 -> F_2 함수 실행하던 정보 ...     
      - 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보      

- 재귀호출    

  - 자기자신을 호출하여 순환 수행하는 것    
  - 일반적인 호출방식보다 프로그램의 크기를 줄이고 간단하게 작성 가능     
  - **factorial 함수 시스템 스택**    
    - 스택 프레임(main) > fact(4) > `fact(n)` ; `n = 4` return `n * fact(n-1)` > 다시 fact(n) 호출, `n의 정보` return `n*fact(n-1)` 반복     
    - 무한 반복을 피하기 위해 `호출`or `중단`을 결정하는 2 부분으로 나뉘어 있어야 함     
  - 재귀 호출의 깊이는 대략 1,000번     
    - pypy는 대략 2,000번     
    - C언어는 메모리가 허용되는 선까지 가능      
    - But, 파이썬이 아니더라도 호출이 1,000번을 넘어간다면 다른 방법 사용      
  - **값이 증가하는 재귀 호출**  (ex. 배열의 원소 출력 - 인덱스 증가)     
    - A[i] 0 ~ N 까지 존재하는 배열    
    - F (i, k ) -> i : 인덱스, k : 경계(끝)   `F(0,N) > F(1,N) > F(2,N) ` ..으로 i + 1     
    - i == k 이면 호출 종료    

  ```python
  def f(i,k):  # 함수 내 반복처럼 보이지만, 사실은 매번 다른 함수 호출하는 것 
      		 # -> 다른 메모리 영역 사용 
      if i == k : # 끝까지 도달하면 종료
          return   # return None 과 동일 
      else:
          print(A[i])
          f(i+1, k) # 다음 이동 
  N = 5
  A = [1,2,3,4,5]
  f(0,N) 
  ```

  - **피보나치 수열**  
  - F0 = 0, F1 = 1 ,F(i) = F(i-1) + F(i-2) `for i >=2`         

  ```python
  def fibo(n):
      if n < 2 :
          return n
      else:
          return fibo(n-1) + fibo(n-2)
      
  -> 엄청난 중복 호출 존재 = 불필요한 연산 필요 = 시간 ↑ 
  각 숫자마다 2번의 연산이 필요하므로 = 항상 시간복잡도 Θ(2^n)    
  
  def fibo(n):
      global cnt
      cnt += 1
      if n < 2 :
          return n
      else:
          return fibo(n-1) + fibo(n-2)
  cnt = 0
  print(fibo(10), cnt)  # 연산 횟수 계산        
  ```

   -> 중복 호출 방지를 위한 방법으로 **메모이제이션** 사용    

- 메모이제이션(memoization)    

  - 이전 계산한 값을 메모리에 저장하여 중복 계산 방지로 전체적인 실행속도 향상하는 기술    
  - 동적 계획법(DP)의 핵심    
  - 말 그대로 메모리에 넣기라는 의미, `라틴어 memorandum 파생` , memorization 에서 r 제외   
  - 피보나치 수에서 fibo(n)의 값을 저장하면 `시간복잡도 Θ(2^n)  -> Θ(n) 로 감소` 가능       
  - 연산 횟수 비교하면 n = 20일 때, ` 일반 21891번 vs 메모이제이션 39번` 

  ```python
  # 메모이제이션 적용한 피보나치 수 알고리즘 1  
  def fibo(n):
      global memo
      if n >= 2 and len(memo) <= n :
          memo.append(fibo(n-1) + fibo(n-2))
      return memo[n]
      
  memo = [0,1]
  
  # 메모이제이션 적용한 피보나치 수 알고리즘 2  
  def fibo(n):
      global memo
      if n >= 2 and memo[n] == 0 :  # 아직 계산안 된 초기화 값이라면  
          memo[n] = fibo(n-1) + fibo(n-2)
      return memo[n]
  
  memo = [0] * (n+1) # 배열 할당, 0으로 초기화
  memo[0] = 0
  memo[1] = 1 
  ```

 

