### 그리디

- 탐욕 알고리즘은 최적해를 구하는데 사용되는 근시안적 방법

  - 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 그리디 접근

- 여러 경우중 하나를 선택할 때 마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식

  - 하지만 그렇게 최종적인 해답을 만들었다고 해서, 그것이 최적의 해답이란 보장은 X

- 한 번 선택한 것은 번복하지 않기 때문에, 대부분 단순하며, 또한 제한적인 문제들에 적용됨   

- 최적화 문제(optimization)란 가능한 해들 중, 가장 좋은 (최대 or 최소) 해를 찾는 문제   

- 동작 과정

  1. 해 선택
     - 현재 상태에서 부분 문제의 최적 해를 구하기 -> 이를 부분해 집합에 추가  
     - `ex >` 가장 단위가 큰 동전 하나를 골라 거스름돈에 추가
  2. 실행 가능성 검사
     - 부분 해 집합이 실행가능한지, 제약조건을 위반하지 않는지 검사  
     - `ex > ` 거스름돈이 줘야하는 액수를 초과하는지 확인 -> 초과하면, 빼고 1로 돌아가서 한 단계 작은 단위의 동전 추가
  3. 해 검사
     - 부분 해 집합이 문제의 해가 되는 지 확인 -> 전체 문제의 해가 완성되지 않았으면 1번부터 다시 반복     
     - `ex > ` 거스름돈이 줘야하는 액수와 일치하는 지 확인 -> 모자라면 1로 돌아가서 반복  

  - 최적해라는 보장은 X

    - `ex > ` 거스름돈 문제에서 단위가 (500, 400, 100, 50, 10) 이 있고 800원을 줘야하면,

      Greedy로는 500 * 1, 100 * 3

      dp, 백트래킹등의 방법으론 400 * 2 로 해결 가능 -> 이게 최적해   

      **따라서 그리디로 해결할 수 없고 dp로 해결할 수 있는 대표적인 문제가 거스름돈 문제**  

- 필수 요소

  - 탐욕적 선택 속성
    - 탐욕적 선택은 최적해로 갈 수 있다. 즉, 탐욕적 선택은 항상 안전하다.
  - 최적 부분 구조
    - 최적화 문제를 정형화하라 -> 하나의 선택을 하면 풀어야할 하나의 하위 문제가 남는다.   
  - **원 문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해** 



- 배낭 짐싸기(Knapsack)

  - 담을 수 있는 문제의 총 무게 = W

    창고에는 n개의 물건, 각 물건에는 물건과 값이 정해져 있음

    배낭이 수용할 수 있는 무게를 초과하지 않으면서, 값이 최대가 되는 물건 담기

  - 유형

    1. 0-1 Knapsack  

       - 물건 쪼개기 X

       - 완전 검색

         - 모든 부분 집합구하기 -> 총무게가 초과하는 집합은 버리기 -> 나머지 집합 중 총 값이 가장 큰 집합 선택
         - 물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가

       - 그리디 

         - 값이 비싼 물건부터 채우기 / 무게가 가벼운 물건부터 채우기 / 무게당 값이 높은 물건부터 채우기 

           등의 방법을 사용할 수 있지만 최적해는 구할 수 X    

    2. Fractional Knapsack  

       - 물건 쪼개기 O
       - 그리디
         - 무게당 값이 높은 물건부터 채우기 -> 최적해 구할 수 O    

  ```python
  S = {item1, item2, .. , itemn} : 물건 집합
  wi = item i의 무게, pi = itme i의 값  
  ```

  

- 회의실 배정 = 활동 선택문제 (Activity-selection problem)   

  - 대표적인 그리디 문제

  - 시작시간, 종료시간이 주어진 회의들이 있을 때, 가능한 많은 회의가 열리기 위해서 어떻게 회의를 배정해야 하는지 구하는 문제

    - 시작, 종료 시간 =si, fi
    - n 개의 활동의 집합 = {A1,A2,...,An}   
    - 서로 겹치지 않는 최대갯수의 활동들의 집합 S를 구하는 문제    

  - 풀이 방법

    1. 종료시간 순으로 활동 정렬
    2. 종료 시간이 가장 빠른 활동 Am 선택
    3. Am 이후 시작하는 활동들 중, 종료 시간이 가장 빠른 활동 선택
    4. 반복

    ```python
    A : 활동 집합, S : 선택된 회의의 집합
    si : 시작시간, fi : 종료시간 , 1<=i<=n
    
    sort A by finish time
    S = A[1]
    j = 1
    for i in range(j+1,n+1):
        # 이전에 선택한 활동의 종료시간 이후의 시작시간을 갖는지 여부 확인
        if si >= fj:
            #S = S U Ai
            S.append(A[i])
        	j = i
    
    # 재귀
    Recursive_selection(i,j):
        m = i+1
        while m < j and sm < fi:
            # m<j : m이 마지막 활동이 아니면
            # 다음활동(m)의 시작시간이, 현재 활동(i)의 종료시간보다 빠르면, 겹치는 거니까 다음으로 넘어가기
            m += 1
       if m < j:
        	return A[m] U Recursive_selection(m,j)
       else:
            return {}
    ```



- baby-gin 문제

  - 탐욕 기법을 통한 해결

    - counts 배열의 각 원소를 체크하여 run / triplet 및 baby-gin 여부 판단    
      - run 조사 -> run이면 counts 배열에서 해당 데이터 삭제
        - if counts[i] >0 , counts[i+1] > 0 , counts[i+2] > 0 
        - 맞으면 -> counts[i] -= 1, counts[i+1] -=1, counts[i+2] -= 1
      - triplet 조사 -> triplet이면 counts 배열에서 해당 데이터 삭제  
        - if counts[i] >= 3 
        - 맞으면 -> counts[i] -= 3

    ```python
    i, inp, tri, run = 0
    inp = int(input())
    c = [0] * 11		# 인덱스 에러 방지를 위해 더미 10,11번째 칸 추가
    
    # counts 배열 만들기
    while i < 6:
        c[inp%10] += 1
        inp //= 10
        i += 1
        
    # run, triplet 조사
    i = 0
    while i < 10:
        if c[i] >= 3:
            c[i] -= 3
            tri += 1
            continue
        if c[i] >0 and c[i+1] > 0 and c[i+2] > 0 :
            c[i] -= 1
            c[i+1] -=1
            c[i+2] -= 1
            run += 1
            continue
        # i번째 자리에 run, triplet이 다 없다면 i 증가
        i += 1
    
    # 결과 출력
    if run + tri == 2 :
        print('baby gin')
    else:
        print('lose')
    ```

    

</br>  

- 탐욕기법과 동적 계획법 비교

| 탐욕 기법                                                    | 동적 계획법                             |
| ------------------------------------------------------------ | --------------------------------------- |
| 매단계, 가장 좋게 보이는 걸 빠르게 선택<br /> -> 지역 최적 선택 | 매단계, 해결한 하위 문제의 해 기반 선택 |
| 하위 문제를 풀기 전, 탐욕적 선택이 먼저 이루어짐             | 하위 문제가 우선 해결                   |
| 탑 - 다운 방식                                               | 바텀-업 방식                            |
| 일반적으로 빠르고 간결                                       | 좀 더 느리고, 복잡                      |

</br>  

- 대표적 탐욕기법의 알고리즘

| 알고리즘                   | 목적                                                | 설명                                                         |        |
| -------------------------- | --------------------------------------------------- | ------------------------------------------------------------ | ------ |
| Prim                       | N개의 노드에 대한 최소 신장트리(MST) 찾기           | 서브트리를 확장하면서 MST 찾는다                             | 그래프 |
| Kruskal                    | N개의 노드에 대한 최소 신장트리(MST) 찾기           | 싸이클이 없는 서브 그래프를 확장하면서 MST 찾는다            | 그래프 |
| Dijkstra<br />(다익스트라) | 주어진 정점에서 다른 정점들에 대한 최단 경로 찾기   | 주어진 정점에서 가장 가까운 정점을 찾고, 그다음 정점을 반복해서 찾는다 | 그래프 |
| Huffman tree & code        | 문서 압축을 위해 문자들의 빈도수에 따라 코드값 부여 | 출현 빈도가 낮은 문자부터 선택해서 이진트리 완성 -> 코드값 부여 | 문자열 |

