## APS(Algorithm Problem Solving) 응용     


### 엔디안

- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법

- HW 아키텍처마다 다름 - 제조 회사마다 다름

- 주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연살할때 올바르게 이해하지 않으면 오류 발생 가능    

  ```python
  x = 0x01020304
  x를 메모리주소에 저장하는 방법
  1) 1000 : 0x04		2) 1000 : 0x01
     1001 : 0x03		   1001 : 0x02
     1002 : 0x02		   1002 : 0x03
     1003 : 0x01		   1003 : 0x04
  1) 리틀 엔디안 : 낮은 메모리 주소에 작은 단위가 옴
  2) 빅 엔디안 : 낮은 메모리 주소에 큰 단위가 옴
      
  # 파이썬에서의 엔디안 확인 코드
  import sys
  print(sys.byteorder)
  ```

  - 빅 엔디안

    - 보통 큰 단위가 앞에 나오며, 

      주로 네트워크에서 사용 (앞에서 들어오는 자료를 먼저 읽으므로)

  - 리틀 엔디안

    - 작은 단위가 앞에 나오며, 

      대다수의 데스트탑 컴퓨터에 사용   



##### 예제5

- `^` 연산(=XOR 연산)을 하면 1인 자리만 토글(반전)되므로 일종의 암호처럼 사용 가능

- 만약 a ^ key 를 한다면

  ```python
  a = 0x86
  key = 0xAA
  
  a = 1000 0110
  key = 1010 1010
  (key에서 A는 10을 의미하므로 10은 2진수로 1010)
  여기서 a ^ key를 한다면, 두 비트가 같으면 0, 다르면 1이므로 계산해보면,
  결과적으론 key에서 1이 있는 자리만 토글(반전)되게 된다.
  a^key = 0010 1100
  
  (a^key) ^key 를 하여 ^ 연산을 2번하면 원상복귀 된다.
  (a^key) ^ key = 1000 0110
  
  즉, key를 알고 있으면, 암호화와 복호화가 가능하다는 뜻
  ```

  

### 진수

- 10진수를 2진수로 쭉 나눴을 때, 처음 나온 나머지를 LSB, 마지막 나머지를 MSB 라고 한다.
  - 즉, 10010 이라는 2진수에 대해 '1'0010 이 MSB, 1001'0' 이 LSB
  - MSB = Most Significant bit
- 2진법 -> 16진법 : 4자리씩 묶어서 표현 
  - 16진법 -> 2진법 : 4자리씩 나열해서 표현
  - 2진법 <-> 8진법은 서로 3자리씩 묶거나 나열해서 표현

- 컴퓨터에서의 음의 정수 표현방법

  1. 부호와 절대값 표현

     - 제일 첫자리를 부호비트로 정하고, 부호 비트를 제외한 나머지 비트에 절대값 표현
     - 즉, 부호비트에서 1이면 `-` 로 정하고 -2를 표현한다면, `1000 0000 0000 0010` 

  2. 1의 보수표현

     - 더해서 모든 비트가 1이 되는 값을 1의 보수라고 함
       - 즉, 원래 비트를 모두 반전시키는 것

     - -6 이라면, 6에 대한 1의 보수는  `1001`  이다.
       -  6 (`0110`) 의 모든 비트에 더하면 모두 1이 되어야하므로
     - `단점` : 0 에 대해서, -0 이라는 값이 생기게 됨
       - `0 = 0000`, ` -0 = 1111 `

  3. 2의 보수표현 : **실제로 저장할 때 사용 되는 표현** 

     - 1의 보수 방법으로 표현된 값의 최하위 비트에 1을 더한다.
       - 1의 보수표현의 단점 극복 가능
       - `-0 = 1111` 에서 1을 더하면 `10000` 이 되는데, 비트수를 유지한다면 1을 버리게되므로 `0000` 이 됨
     - 더해서 자릿수가 하나 늘어나는 값을 2의 보수라고 한다.
     - -6이라면, 6에 대한 2의 보수는 `1010` 이다.
       - 6(`0110`) 을 반전하면 `1001` 이고 최하위비트에 1을 더하면 자리올림이 생기므로 `1010` 
     - `-1(1111)` + `2(0010)` 는 10001 이지만, 비트유지를 위해 앞은 버리므로 `0001` 이 되어 즉 `1`로 정상적으로 계산이 완료된다.



### 실수

- 컴퓨터는 실수를 표현하기 위해 부동 소수점 표기법(소수점의 위치를 고정시켜 표현하는 방식) 사용

  - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정 -> 밑 수의 지수승으로 표현

    `1001.0011 = 1.0010011 * 2^3 ` 

    `1.0010011 = 1001.0011 * 2^(-3)` 

- 컴퓨터는 실수를 근사적으로 표현 

  - 즉, 2진법으로 표현할 수 없는 형태의 실수(소수점)는 근사값으로 저장되는데, 이 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴  
    - 소수점이 있는 실수 중에선, 2진수에서 1비트가 변했는데 실제 실수는 크게 변화하는 경우가 존재
    - 그래서 실수끼리 비교할 땐, `|a-b| < 1e-6` 처럼 극히 작은 숫자를 정해서 차이가 해당 숫자보다 작으면 같다고 인식하는 등의 방법 사용   

- 실수 자료형의 유효 자릿수(10진수) 존재

  - 유효 자릿수 : 소수점이 없다생각하고 그냥 모든 숫자의 자릿수
  - 32 비트 실수형 유효자릿수 : 6
  - 62 비트 실수형 유효자릿수 : 15   

- 파이썬에서의 실수 표현 범위

  - 내부적으로 더 많은 비트를 사용하여 훨씬 넓은 범위의 실수 사용 가능
  - 최대 약 `1.8 * 10^308 ` 까지 표현가능하고, 이 이상은 inf로 표현
  - 최소 약 `5.0 * 10^(-324)` 로 표현가능하고, 이 이하는 0으로 표현

#### - 실수 저장 형식

- IEEE754 형식 따름
- 가수부는 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
- 지수부는 실제 소수점의 위치를 지수 승으로 표현한 것
- 파이썬은 상관없지만, 자료형이 있는 언어에선 자릿수가 많은 배정도 실수 사용   



- 단정도 실수(32 bit)

  - (지수의)부호 1비트 + 지수 8비트 + 가수 23비트

  - `1001.0011 = 1.0010011 * 2^3 `  의 경우에선 

    3 -> 지수부

    0010011 -> 가수부

- 배정도 실수(64 bit)

  - 부호 1비트 + 지수 11 비트 + 가수 52비트



- 단정도 실수의 가수 부분 만드는 방법

  - 정수부의 첫 자리가 1이 되도록 오른쪽으로 shift

  - 소수점 이하를 23비트로 만드기

  - 소수점 이하만을 가수 부분에 저장

  - 지수 부분은 shift 한 자릿수만큼 증가 or 감소

    ```python
    1001.0011
    1.0010011 * 2^3 
    # shift 3번이므로 지수 부분 3만큼 증가
    1.0010011 0000 0000 0000 0000 
    # 소수점 이하 23비트로 만들기 위해 16비트 추가
    
    0010011 0000 0000 0000 0000 를 가수부분에 저장
    ```

- 단정도 실수의 지수 부분 만드는 방법

  - 지수부에는 8비트가 배정되므로 256개의 상태 나타내기 가능

    - -127 ~ 128 까지 표현 가능

  - 숫자로는 0~255까지이지만, 음수값도 있으므로 익세스(excess) 표현법 사용

    - 익세스 표현법 : 지수부의 값을 반으로 나누기 -> 그 값을 0으로 간주 

      -> 음수지수, 양수지수 표현

    | 실제지수 | 2진수     | 10진수 |
    | -------- | --------- | ------ |
    | 128      | 1111 1111 | 255    |
    | 127      | 1111 1110 | 254    |
    | 1        | 1000 0000 | 128    |
    | 0        | 0111 1111 | 127    |
    | -1       | 0111 1110 | 126    |
    | -127     | 0000 0000 | 0      |

    - 0~255까지 2진수로 표현된 값의 절반 부분을 0으로 생각
    - 10진수 값에서 -127하면 실제 지수값   

  - 즉, `1.0010011 * 2^3 ` ->

    `0 | 1000 0010 | 0010011 0000 0000 0000 0000` 로 표현 가능

    `부호 | 지수 | 가수` 

  
