### 그래프 기본

- 그래프는 아이템들과 이들 사이의 연결 관계이며, 정점들의 집합과 이들을 연결하는 간선들의 집합으로 구성된 자료구조    

- V개의 정점을 가지는 그래프는 최대 V * (V-1)/2 개의 간선이 가능하다    

- 선형 자료구조나 트리 자료구조로 표현하기 어려운 N : N 관계를 가지는 원소들을 표현하기에 용이    

- 그래프 유형   

  - 무향 그래프
  - 유향 그래프  
  - 가중치 그래프   
    - 간선마다 비용 혹은 값이 적혀있는 그래프   
  - 사이클 없는 방향 그래프(DAG)       
  - 완전 그래프
    - 정점들에 대해 가능한 모든 간선들을 가진 그래프  
  - 부분 그래프   
    - 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프    

- 인접 정점   

  - 두개의 정점에 간선이 존재하면 서로 인접해있다고 한다.    
  - 완전 그래프에 속한 임의의 두 정점들은 모두 인접    

- 그래프 경로   

  - 경로란 간선들을 순서대로 나열한 것   

  - 단순 경로

    - 경로 중 한 정점을 최대 1번만 지나는 경로   

      = 한번 지난 곳은 다시 지나지 않는 경로    

  - 사이클  

    - 시작한 정점에서 끝나는 경로    

- 그래프 표현   

  - 간선의 정보를 저장하는 방식, 메모리, 성능 등을 고려해서 결정   

  - 인접 행렬   

    - 두 정점을 연결하는 간선의 유무를 행렬로 표현   

    - V * V 크기의 2차원 배열을 이용    

    - 행 번호(시작점)와 열 번호(도착점)는 그래프의 정점에 대응    

    - 두 정점이 인접하고 있으면 1, 인접하지 않으면 0으로 표현       

    - 배열의 배열(포인터 배열)    

    - 무향 그래프 : i 번째 행의 합 = i번째 열의 합 = Vi의 차수     

    - 유향 그래프 : i 번째 행의 합 = Vi의 진출 차수 (나가는 간선의 수)     

      ​						i 번째 열의 합 = Vi의 진입 차수 (들어오는 간선의 수)   

    - 만들기 편리하다는 장점이 있지만, 너무 많은 공간을 차지한다는 단점 존재      

      

  - 인접 리스트  

    - 각 정점마다 해당 정점으로 나가는 간선의 정보 저장    

      = 각 정점에 대한 인접 정점들을 순차적으로 표현한 것    

    - 하나의 정점에 대해 인접 정점들을 각각 노드로 하는 연결 리스트로 저장    

    - 무향 그래프  

      - 노드의 수 = 간선의 수 * 2
      - 각 정점의 노드 수 = 정점의 차수   

    - 유향 그래프  

      - 노드의 수 = 간선의 수   
      - 각 정점의 노드 수 = 정점의 진출 차수    

  - 간선의 배열   

    - 간선(시작점,끝점)을 배열에 연속적으로 저장    

​    

### 그래프 순회(탐색)   

- 그래프 순회는 비선형구조인 그래프로 표현된 모든 정점을 빠짐없이 탐색하는 것을 의미    

- 깊이 우선 탐색(DFS)   

  - 시작 정점의 한 뱡향으로 갈 수 있는 곳까지 계속 탐색하다가, 더이상 갈 곳이 없으면 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 돌아와서 다른 방향의 정점으로 탐색을 반복하여 결국 모든 정점을 방문하는 순회 방법    

  - 가장 마지막에 만났던 갈림길의 정점으로 돌아가 다시 반복하므로, 즉, 진행 방향의 역순으로 돌아가므로 후입선출(LIFO) 구조의 스택 사용         

    = 재귀를 썼으면 그냥 return 하면 되고, 반복문을 썼으면 stack 사용        

    - 선택지를 모두 stack에 push 하는 방법, 방문 경로를 stack 에 push 하는 방법 등 가능      

  - 스택의 구현   

    - 스택을 구현하기 위해 필요한 저장소와 연산    
    - 자료를 선형으로 저장할 저장소   
      - C언어에서는 배열 사용 가능    
      - 저장소 자체를 스택으로 부르기도 함   
      - 스택에서 마지막 삽입된 원소의 위치를 top라 부름   
    - 연산   
      - `push`, `pop`, `isEmpty` , `peek - 스택의 top에 있는 원소 반환`   
      - top + 1 -> push
      - pop -> top - 1    
        - top에 있는 값을 꺼내는게 pop    

- 너비 우선 탐색(BFS)   

  - 탐색 시작점의 인접정점들을 모두 방문 -> 방문했던 정점을 시작점으로 하여 다시 인접 정점을 차례로 방문하는 방식    

  - 인접정점들을 탐색한 후, 다시 BFS를 진행하므로, 선입선출 형태의 자료구조인 큐 활용   

  - 큐의 구현   

    - 연산   

      - `삽입 - neQueue`, `삭제 - deQueue`     

      - 삽입은 뒤에서만, 삭제는 앞에서만 이루어짐     

      - rear는 마지막 저장위치, front는 마지막에 꺼내진 위치      

        frot == rear 라면, que는 비어있는 상태   

      - front = rear = -1 로 설정하여 que 생성    

      - rear + 1 -> enQueue  
      - front + 1 -> deQueue      
        - front에 있는 값을 꺼내는게 deQueue        

