## 자료구조   
###### C, C++, 자바, 파이썬 등에 여러 언어에 있는 프로그래밍 구조이며, 메모리에 정보를 서로 다른 방법으로 저장할수 있도록 한다.         
###### ※ 노드 : 직사각형으로 나타낼 수 있는 메모리 덩어리, 그래프에서의 노드와 비슷한 역할   
</br>   

## 1. 기본 원칙   

#### 1-1. 구조체(struct)   
###### C에서 자신만의 구조를 만들 수 있는 키워드로 여러 자료형을 담는 그릇       
``` 
typedef struct 
{ (자료형1) (이름1); (자료형2) (이름2); } 
(새로운 자료명);
```   
#### 1-2. 점 표기법   
###### 구조체 안에 포함된 속성값은 점 연산자를 사용하여 (새로운 자료명).(이름1)로 표현할 수 있다.     
ex) 
``` 
typedef struct   
{ string abc; string cde; }   
aph;   
```      
-> 속성값 표현 : aph.abc 또는 aph.cde 등등      

#### 1-3. 별표 연산자 (```*```)   
###### 메모리 덩어리로 접근할 수 있는 역참조 연산자     
&연산자가 변수의 주소를 나타낸다면, ```*``` 연산자는 해당 주소로 이동하라는 뜻을 나타낸다.     

</br>   

## 2. 배열과 연결리스트    
- 배열과 연결 리스트는 값들의 리스트를 저장하는 방법        
- **배열은 값들이 연속적으로 이어져있어야 하지만, 연결 리스트는 메모리 내에서 떨어져있어도 리스트 저장 가능**      
  　　     
- 배열의 장점 : 1. [ ]를 활용하여 문법적으로 쉽게 인덱싱할 수 있다.    
　　　　　　2. 대괄호 안에 인덱스를 넣음으로 바로 접근할 수 있어 매우 빠르므로 바이너리 검색 같은 곳에 적용 가능하다.       
- 배열의 단점 : 1. 고정된 메모리 덩어리이므로 값을 추가하고 싶을 땐 O(n)만큼의 동작 시간이 소요되어 느리다.       
　　　　　　2. 메모리 내에서 연속된 공간으로 이루어져야 해서 값을 추가하는 등의 크기 조정 과정이 복잡하다.    
  　　   
- 연결 리스트의 장점 : 1. 값이 저장된 공간이 연속적일 필요가 없으므로 배열보다 좀 더 효율적인 메모리 사용이 가능하다.      
 　　　　　　2. 포인터로 연결되어있으므로 배열보다 값을 추가하는 등의 크기 조정이 자유롭다.
- 연결 리스트의 단점 : 1. 포인터를 저장할 공간이 필요하므로 배열보다 메모리가 2배 더 소모된다.     
</br>   

## - 연결 리스트   
#### 메모리 덩어리 여러 개를 포함한 데이터 구조이며 포인터로 연결되어 있다.           
- 마지막엔 다음 메모리 주소 대신 포인터인 널(NULL)을 사용함으로 종료 선언 - 널(NUL) 종단 문자(\0)와는 다른 것으로 16진법 0(0x0)    
- 하나를 저장할 때 __*값을 저장할 공간*__ 과 __*다음 메모리 덩어리의 주소(포인터)를 저장할 공간*__ 을 같이 저장하여 리스트 연결   
 즉, 2개의 필드로 이루어져 있다.       
1. number - 정수, 값      
2. next - 관례적인 이름이며 다른 이름으로 불러도 상관 X, 리스트의 다음 요소를 가리키는 메모리 덩어리      

``` 
typedef struct node    // 마지막 줄에 node가 나오기 전엔 node라는 단어를 못 쓰므로 앞에서 선언하는 것   
{ int number;
  struct node *next; }   
  node;    // 이 node 구조체의 별칭   
  ```

</br>    

## - 배열   
#### 값들의 리스트, 여러 개의 같은 자료형 값을 지닌 하나의 변수 설정할 때 사용     
###### 배열의 크기(갯수)는 처음 정의할때 부터 설정해야 한다.   
1. (자료형) (배열명)[갯수];   
2. (배열명)[0];    
3. (배열명)[1];   
 ...          
``` 
int (배열명)[갯수];   // 배열 선언   
for (int i = 0; i < n; i++)   // for 루프   
{ (배열명)[i]=get_int("~~~ %i: ",i); }   // 사용자로부터 배열값 받기   
```        
-> 배열값 정적 초기화      
(자료형) (배열명)[갯수] = { 배열 값 나열 };   

### (1) 2차원 배열　(배열명)[j][k]    
1. [j] : 배열의 인덱스-j번째 값    
2. [k] : j번째 값을 하나의 배열로 보고 그 중 k번째 문자      

### (2) 배열의 크기 조정 (i 크기 -> j 크기)  
###### 배열의 값은 처음부터 정해져있으므로 j 크기만큼 메모리를 재할당한 후 기존의 값들을 복사하고 i 크기의 메모리는 할당 해제     
1. ``` int *list = malloc(i * sizeof(int)); ``` 정수 자료형 i개로 이루어진 메모리를 malloc 함수로 할당하여 배열 list 정의      
2. 크기 조정하고 싶다면, realloc 함수를 사용하여 메모리 재할당 및 기존 값 복사     
3. list와 재할당한 배열이 같은 곳을 가리키도록 저장한 후 새로운 값 저장   
```
int *tmp = realloc(list, j * sizeof(int));    // tmp에 j 크기만큼 메모리 재할당 및 기존 값 복사     
if (tmp == NULL)    // 혹시 메모리 부족하면 표시하도록 명령   
{ return 1; } 
list = tmp;     // list가 tmp와 같은 곳 가리키도록 저장   
list[3] = 2;    // 새로운 값 있으면 이렇게 저장   
~ 작업 ~   
free(list);    // 마지막엔 메모리 초기화   

``` 

