## 자료구조   
###### C, C++, 자바, 파이썬 등에 여러 언어에 있는 프로그래밍 구조이며, 메모리에 정보를 서로 다른 방법으로 저장할수 있도록 한다.         
###### ※ 노드 : 직사각형으로 나타낼 수 있는 메모리 덩어리, 그래프에서의 노드와 비슷한 역할   
</br>   

## 1. 기본 원칙   

#### 1-1. 구조체(struct)   
###### C에서 자신만의 구조를 만들 수 있는 키워드로 여러 자료형을 담는 그릇       
``` 
typedef struct 
{ (자료형1) (이름1); (자료형2) (이름2); } 
(새로운 자료명);
```   
#### 1-2. 점 표기법   
###### 구조체 안에 포함된 속성값은 점 연산자를 사용하여 (새로운 자료명).(이름1)로 표현할 수 있다.     
ex) 
``` 
typedef struct   
{ string abc; string cde; }   
aph;   
```      
-> 속성값 표현 : aph.abc 또는 aph.cde 등등      

#### 1-3. 별표 연산자 (```*```)   
###### 메모리 덩어리로 접근할 수 있는 역참조 연산자     
&연산자가 변수의 주소를 나타낸다면, ```*``` 연산자는 해당 주소로 이동하라는 뜻을 나타낸다.     

</br>   

## 2. 배열과 연결리스트    
- 배열과 연결 리스트는 값들의 리스트를 저장하는 방법        
- **배열은 값들이 연속적으로 이어져있어야 하지만, 연결 리스트는 메모리 내에서 떨어져있어도 리스트 저장 가능**      
  　　     
- 배열의 장점 : 1. [ ]를 활용하여 문법적으로 쉽게 인덱싱할 수 있다.    
　　　　　　2. 대괄호 안에 인덱스를 넣음으로 바로 접근할 수 있어 매우 빠르므로 바이너리 검색 같은 곳에 적용 가능하다.       
- 배열의 단점 : 1. 고정된 메모리 덩어리이므로 값을 추가하고 싶을 땐 O(n)만큼의 동작 시간이 소요되어 느리다.       
　　　　　　2. 메모리 내에서 연속된 공간으로 이루어져야 해서 값을 추가하는 등의 크기 조정 과정이 복잡하다.    
  　　   
- 연결 리스트의 장점 : 1. 값이 저장된 공간이 연속적일 필요가 없으므로 배열보다 좀 더 효율적인 메모리 사용이 가능하다.      
 　　　　　　2. 포인터로 연결되어있으므로 배열보다 값을 추가하는 등의 크기 조정이 자유롭다.
- 연결 리스트의 단점 : 1. 포인터를 저장할 공간이 필요하므로 배열보다 메모리가 2배 더 소모된다.     
</br>   

## - 연결 리스트   
#### 메모리 덩어리 여러 개를 포함한 데이터 구조이며 포인터로 연결되어 있다.           
- 마지막엔 다음 메모리 주소 대신 포인터인 널(NULL)을 사용함으로 종료 선언 - 널(NUL) 종단 문자(\0)와는 다른 것으로 16진법 0(0x0)    
- 하나를 저장할 때 __*값을 저장할 공간*__ 과 __*다음 메모리 덩어리의 주소(포인터)를 저장할 공간*__ 을 같이 저장하여 리스트 연결   
 즉, 2개의 필드로 이루어져 있다.       
1. number - 정수, 값      
2. next - 관례적인 이름이며 다른 이름으로 불러도 상관 X, 리스트의 다음 요소를 가리키는 메모리 덩어리      


#### - 기본 단위 node 구조체 정의        
``` 
typedef struct node    // 마지막 줄에 node가 나오기 전엔 node라는 단어를 못 쓰므로 앞에서 선언하는 것   
{ int number;
  struct node *next; }    // 연결 리스트는 그 다음 메모리 덩어리의 주소를 같이 저장하므로   
  node;    // 이 node 구조체의 별칭   
  ```   
  
#### - 구현   
```
int main(void)  
{
//리스트 첫 시작
node *list = NULL;      // 처음에는 비어있으므로 첫 번째 리스트에는 아무것도 없어서 NULL로 초기화     

node *n = malloc(sizeof(node));    // 메모리 덩어리 node를 저장할 공간을 malloc로 할당하고 그 반환값을 node의 주소 n에 저장
if (n != NULL)          // n이 널이라면 메모리 부족으로 할당안된거니 종료 실행하는 등 사용처에 따라 달라진다.   
{ n->number = 2;        // n의 number값에 2 추가 = node n은 2를 기록함,  (*n).number = 2;와 같은 의미를 C 문법으로 작성   
  n->next = NULL; }     // 아직 다음 리스트가 없어 비어있기 때문  
  
list = n;     // 이제 list가 node n을 가리키게 됨   

n = malloc(sizeof(node));     // 다른 node를 연결하기 위해 새로운 메모리 할당    
if (n != NULL)
{ n ->number = 4;
  n->next = NULL; }       // 4를 기록하는 새로운 node 추가  

// 리스트 맨뒤에 값 추가 
node *tmp = list;          // 임시 포인터 tmp가 list와 같은 곳을 가리키도록 함
while (tmp->next != NULL)   // tmp가 가리키는 곳의 next값이 널이라면 그게 현재 리스트의 끝을 의미하므로   
{ tmp = tmp->next; }        // 널이 아니라면 다음을 계속 찾아가며 스스로 업데이트   
tmp->next = n;

// list와 2 사이에 값을 끼워넣을 때 = 첫 부분에 값 추가
node *n = malloc(sizeof(node));    // 끼워넣을 값을 가지는 새로운 노드의 메모리 할당  
if (n != NULL)
{ n->number = 1;
  n->next = NULL; } 
n->next = list;           // 메모리 누수를 막기 위해 n 포인터가 먼저 list가 가리키고 있는 것을 중복으로 가리키게 만듬
list = n;                 // 그 후 list가 n 포인터를 가리키게 하여서 시작이 list임을 알림   

// 위처럼 처음이 아니라 중간에 끼워넣는다면 루프로 탐색하고 부등호를 사용하여 적절한 위치 찾아내야 함  
// 즉, 반복문과 대소비교, 포인터 업데이터 과정 필요   

// list에 연결된 노드의 number 값 출력
for(node *tmp = list; tmp != NULL; tmp = tmp-> next)    // next값이 널이라면 리스트의 끝이므로 종료 조건   
{ printf("%i\n", tmp->number); }   

// 메모리 해제 
while (list != NULL)
{ node *tmp = list->next;
  free(list);
  list = tmp; }

}
```    


</br>    

## - 배열   
#### 값들의 리스트, 여러 개의 같은 자료형 값을 지닌 하나의 변수 설정할 때 사용     
###### 배열의 크기(갯수)는 처음 정의할때 부터 설정해야 한다.   
1. (자료형) (배열명)[갯수];   
2. (배열명)[0];    
3. (배열명)[1];   
 ...          
``` 
int (배열명)[갯수];   // 배열 선언   
for (int i = 0; i < n; i++)   // for 루프   
{ (배열명)[i]=get_int("~~~ %i: ",i); }   // 사용자로부터 배열값 받기   
```        
-> 배열값 정적 초기화      
(자료형) (배열명)[갯수] = { 배열 값 나열 };   

### (1) 2차원 배열　(배열명)[j][k]    
1. [j] : 배열의 인덱스-j번째 값    
2. [k] : j번째 값을 하나의 배열로 보고 그 중 k번째 문자      

### (2) 배열의 크기 조정 (i 크기 -> j 크기)  
###### 배열의 값은 처음부터 정해져있으므로 j 크기만큼 메모리를 재할당한 후 기존의 값들을 복사하고 i 크기의 메모리는 할당 해제     
1. ``` int *list = malloc(i * sizeof(int)); ``` 정수 자료형 i개로 이루어진 메모리를 malloc 함수로 할당하여 배열 list 정의      
2. 크기 조정하고 싶다면, realloc 함수를 사용하여 메모리 재할당 및 기존 값 복사     
3. list와 재할당한 배열이 같은 곳을 가리키도록 저장한 후 새로운 값 저장   
```
int *tmp = realloc(list, j * sizeof(int));    // tmp에 j 크기만큼 메모리 재할당 및 기존 값 복사     
if (tmp == NULL)    // 혹시 메모리 부족하면 표시하도록 명령   
{ return 1; } 
list = tmp;     // list가 tmp와 같은 곳 가리키도록 저장   
list[3] = 2;    // 새로운 값 있으면 이렇게 저장   
~ 작업 ~   
free(list);    // 마지막엔 메모리 초기화   

``` 

