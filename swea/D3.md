# D3 난이도    
</br>   

## 정답 코드   

### 5178. 노드의 합

```python
T = int(input())

for tc in range(1,T+1):
    N,M,L = map(int,input().split())
    node = [0] * (N+1)
    for k in range(M):
        idx, n = map(int,input().split())
        node[idx] = n
    for m in range(N//2,0,-1):
        if node[m]==0:
            if (m*2 <= N) and (m*2+1 <=N):
                node[m] = node[m*2] + node[m*2+1]
            elif m*2+1 > N:
                node[m] = node[m*2]
    print('#{} {}'.format(tc, node[L]))
```

</br>   
<hr>   

### 1244. 최대상금   
   
```python   
import sys
sys.stdin = open('input.txt')

def find_big(li,n,small):
    max_idx = n-1
    for k in range(n-1,small,-1):
        if board[max_idx] < board[k]:
            max_idx = k
    return max_idx

def find_small(li,n,big):
    min_idx = 0
    for j in range(big):
        if board[min_idx] > board[j]:
            min_idx = j
    return min_idx


T = int(input())
for tc in range(1,T+1):
    N = list(input().split())
    trade = int(N[-1])
    board = list(N[0])
    n = len(board)
    # 뒤에서 찾을땐 가장 큰수, 앞에서 찾을땐 가장 작은수 -> 그렇게 교환
    b, s = n,0
    # 교환 횟수가 남아있다면
    while trade:
        # 탐색 시작지점 s가 마지막인덱스가 아니라면
        if s <= n-1:
            # 뒤에서부터 s까지 탐색하면서 가장 큰 값찾기 -> 큰 값은 앞에 있을 수록 좋으므로, 가장 뒤에 있는 값을 옮기기 위해서
            b = find_big(board,n,s-1)
            # 가장 큰 값이 숫자판에서 중복없이 있다면
            if board.count(board[b]) == 1:
                # 찾은 값의 인덱스가 현재 시작지점과 같지 않다면
                if s != b :
                    # 교환, 교환횟수 - 1, 시작지점 +1
                    board[b], board[s] = board[s], board[b]
                    trade -= 1
                    s += 1
                # 찾은 값이 인덱스가 현재 시작지점과 같다면, 교환해봤자 제자리걸음이므로 교환없이 시작지점만 + 1
                else:
                    s += 1
            # 가장 큰 값이 숫자판에서 중복이라면
            else:
                # 맨 앞에서부터 해당 값의 인덱스까지만 탐색하면서 가장 작은 값 찾기 -> 작은 값은 뒤에 있을 수록 좋으므로 가장 앞에 있는 작은 값을 옮기기 위해서
                m = find_small(board, n, b)
                # 가장 작은 값과 찾은 큰 값 교환 , 교환 횟수 - 1
                board[m], board[b] = board[b], board[m]
                trade -= 1
        # 탐색 시작지점 s가 마지막인덱스라면, 크기에따른 교환은 모두 끝낸것이므로 교환횟수를 모두 소모할때까지 제일 작은 값들인 마지막 두 값을 무한히 교환
        else:
            board[n-1], board[n-2] = board[n-2], board[n-1]
            trade -= 1

    print('#{} {}'.format(tc, ''.join(board)))   
```   

</br>    
<hr>   

### 5248. 그룹 나누기   
```python  
def dfs(n):
    visited[n] = 1
    res.append(n)
    for w in arrList[n]:
        if visited[w] == 0:
            visited[w] = 1
            dfs(w)
        else:
            for k in result:
                if w in k:
                    k.append(n)
                    res.clear()

T = int(input())
for tc in range(1,T+1):
    N, M = map(int,input().split())
    li = list(map(int,input().split()))
    arrList = [[] for _ in range(N+1)]
    check = set()
    for i in range(M):
        a1, a2 = li[i*2], li[i*2+1]
        arrList[a1].append(a2)
        arrList[a2].append(a1)
        check.add(a1)
        check.add(a2)
    visited = [0] * (N + 1)
    cnt = N - len(check)
    result = []
    for k in check:
        if visited[k] : continue
        res = []
        dfs(k)
        if res:
            result.append(res)
    print('#{} {}'.format(tc,cnt+len(result))) 
```   
- dfs 재귀 이용하여 풀이    

</br>   
<hr>    
   
### 2814. 최장 경로   
```python  
def dfs(n):
    global res
    visited[n] = 1
    res += 1
    result.append(res)
    for w in arrList[n]:
        if visited[w] == 0 :
            dfs(w)
            visited[w] = 0
            res -= 1


T = int(input())

for tc in range(1,T+1):
    N,M = map(int,input().split())
    arrList = [[] for _ in range(N+1)]
    for _ in range(M):
        x,y = map(int,input().split())
        arrList[x].append(y)
        arrList[y].append(x)
    result = []
    for i in range(1,N+1):
        res = 0
        visited = [0] * (N + 1)
        dfs(i)

    print('#{} {}'.format(tc, max(result)))
```   
- bfs 로 구현할 시 오류 발생   

<br>  
<hr>    

### 5209. 최소 생산 비용     
```python   
def perm(n,k,ans):
    global min_cost
    if ans > min_cost:
        return
    if k == n:
        if ans < min_cost:
            min_cost = ans
    else:
        for i in range(n):
            if not used[i]:
                p[k] = arr[i]
                used[i] = 1
                perm(n,k+1, ans+cost[k][p[k]])
                used[i] = 0


T= int(input())
for tc in range(1,T+1):
    N = int(input())
    cost = [list(map(int,input().split())) for _ in range(N)]
    p = [0] * N
    arr = [i for i in range(N)]
    used = [0] * (N+1)
    min_cost = 99 * (N ** 2)
    perm(N,0,0)
    print('#{} {}'.format(tc,min_cost))
```   
<hr>   
</br>     

### 5204. 병합정렬    
```python    

def quick(l,L,R):
    if L < R:
        s = partition(l,L,R)
        quick(l,L,s-1)
        quick(l,s+1,R)

def partition(l,L,R):
    # 피봇값을 제일 왼쪽값으로 설정
    p = l[L]
    i,j = L,R
    while i <= j :
        while i <= j and l[i] <= p:
            i += 1
        while i <= j and l[j] >= p :
            j -= 1
        if i <= j :
            l[i], l[j] = l[j], l[i]
    l[L], l[j] = l[j], l[L]
    return j

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    lst = list(map(int,input().split()))
    quick(lst, 0, N-1)
    print('#{} {}'.format(tc,lst[N//2]))
```     


</hr>   
</br>   

### 5205. 퀵정렬    
```python   
def quick(l,L,R):
    if L < R:
        s = partition(l,L,R)
        quick(l,L,s-1)
        quick(l,s+1,R)

def partition(l,L,R):
    # 피봇값을 제일 왼쪽값으로 설정
    p = l[L]
    i,j = L,R
    while i <= j :
        while i <= j and l[i] <= p:
            i += 1
        while i <= j and l[j] >= p :
            j -= 1
        if i <= j :
            l[i], l[j] = l[j], l[i]
    l[L], l[j] = l[j], l[L]
    return j

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    lst = list(map(int,input().split()))
    quick(lst, 0, N-1)
    print('#{} {}'.format(tc,lst[N//2]))
```    
</br>  
<hr>      

### 5189. 전자카트     
```python    
def perm(n,m,k):
    global arr, p
    if k == n:
        if p[0] == 1:
            start.append(p[:])
        elif p[1] ==1:
            end.append(p[:])
        else:
            li.append(p[:])
    else:
        for i in range(m):
            if not used[i]:
                p[k] = arr[i]
                used[i] = 1
                perm(n,m,k+1)
                used[i] = 0

def search(cnt, sta, add):
    global ans
    si,sj = sta

    if cnt == N-1:
        add += board[sj][1]
        if ans > add:
            ans = add
        return
    else:
        for l in li:
            if l[0] == sj and not used[l[1]]:
                ls,le = l
                if board[ls][le] != 0 :
                    temp = board[ls][le]
                    board[ls][le] = 0
                    used[ls] = 1
                    search(cnt+1, l, add + temp)
                    board[ls][le] = temp
                    used[ls] = 0

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [[0] * (N+1)] + [[0] + list(map(int,input().split())) for _ in range(N)]
    used = [0]*(N+1)
    arr = list(range(1,N+1))
    li = []
    end = []
    start = []
    p = [0] * 2
    ans = 9999999999999
    perm(2,N,0)
    used = [0] * (N+1)
    for s in start:
        si, sj = s
        a = board[si][sj]
        board[si][sj] = 0
        search(1, s, a)
    print('#{} {}'.format(tc,ans))
```    
- 순열 + 재귀 이용      

<hr>    
<br><br>   

### 5201. 컨테이너 운반     
```python    
def add():
    # 최종무게 ans를 0으로 초기화
    ans = 0
    # 트럭 중량에 대해 반복문 순회
    for max_weight in t:
        # 컨테이너 무게에 대해 반복을 돌면서
        for weight in w:
            # 컨테이너 무게가 현재 트럭의 중량보다 작거나 같으면 최종 무게 ans에 추가
            if weight <= max_weight:
                ans += weight
                # 이번 트럭에 컨테이너를 실은 것이므로 해당 컨테이너 무게는 배열에서 삭제
                w.remove(weight)
                # 트럭 1대당 1개의 컨테이너만 실을 수 있으므로 실을 컨테이너 찾았으면 break
                break
    return ans


T = int(input())
for tc in range(1,T+1):
    N, M = map(int,input().split())     # 컨테이너 , 트럭 수
    # 중량이 큰 트럭에 무거운 무게를 실어야 효율적이므로 트럭 중량과 컨테이너 무게 배열 모두 내림차순 정렬
    w = sorted(list(map(int,input().split())),reverse=True)  # 컨테이너 무게 내림차순정렬
    t = sorted(list(map(int,input().split())),reverse=True)  # 트럭 중량 내림차순 정렬
    print('#{} {}'.format(tc,add()))
```    

<hr>   
<br><br>    

### 5188. 최소합    
```python    
def search(n, li, start, end, add):
    global ans
    si,sj = start
    ei,ej = end

    if ans < add + li[ei][ej]:
        return
    if si == n-1 and sj == n-1:
        if ans > add:
            ans = add
        return

    else:
        for k in range(2):
            ni = si + di[k]
            nj = sj + dj[k]
            if 0 <= ni < n and 0 <= nj < n:
                val = li[ni][nj]
                if val != -1:
                    add += val
                    li[ni][nj] = -1
                    search(n,li,[ni,nj],end,add)
                    li[ni][nj] = val
                    add -= val

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [list(map(int,input().split())) for _ in range(N)]
    di = [0,1]     # 상 하
    dj = [1,0]      # 우 좌
    ans = 9999999999999999999
    init = board[0][0]
    board[0][0] = -1
    search(N,board[:], [0,0], [N-1,N-1], init)
    print('#{} {}'.format(tc,ans))
```   

</hr>   
</br></br>     

### 5099. 피자굽기    
```python    
T = int(input())
for tc in range(1,T+1):
    N, M = map(int,input().split())
    pizza = list(map(int,input().split())) # 피자번호 순서대로의 치즈 양
    q = [] * N                              # 화덕 queue 생성
    front = 0                              # queue 초기화
    cnt = list(range(1,N+1))              # 화덕 내부 피자 번호
    for _ in range(N):
        q.append(pizza.pop(0))           # 화덕 최대치만큼 피자 넣기

    while len(q) > 1:
        if q[front] != 0:               # 화덕 내부 1번째 치즈양이 0이 아니면
            q[front] //= 2              # //2 만큼 감소
            if q[front] == 0:           # 화덕 내부 1번째 치즈양이 0 이면
                q.pop(front)            # 화덕 내부에서 해당 피자 꺼내기
                if pizza:               # 아직 넣을 피자가 남았다면
                    q.insert(front,pizza.pop(0))    # 남은 피자 중 첫번째 피자를, 빼낸 자리에 넣기
                    N += 1                      # 처음에 화덕에 N번까지 넣었으니까, 새로 넣을 피자는 N+1번 -> N+2번 ...
                    cnt[front] = N              # 화덕 내부 피자 번호 갱신
                else:                   # 넣을 피자가 없다면
                    cnt.pop(front)      # 치즈 양이 0이 된 피자를 꺼내고 새로 넣는게 없으므로 화덕 내부 피자 번호도 같이 없애기
                    front %= len(q)     # 인덱스 에러 방지
            else:
                front = (front + 1) % len(q)        # front 갱신(화덕 내부에서 돌아야하므로 q 길이로 나눈 나머지로 갱신)
    print('#{} {}'.format(tc, cnt[0]))
```      

<hr>   
</br></br>     


### 5208. 전기버스2    
```python    
def dfs(now_bus,cnt):
    global min_cnt, N
    if cnt > min_cnt :
        return
    if now_bus >= N-1:
        return
    # 현재 정류장번호가 도착점이라면 최솟값 갱신
    if now_bus + battery_list[now_bus] >= N-1:
        if min_cnt > cnt :
            min_cnt = cnt
            return
    # 아직 도착점에 도착하지 않았다면
    elif now_bus < N-1:
        for i in range(1, battery_list[now_bus]+1):
            now_bus += i
            dfs(now_bus, cnt+1)
            now_bus -= i
T = int(input())
for tc in range(1,T+1):
    li = list(map(int,input().split()))
    N, battery_list = li[0], li[1:]
    # 정류장은 최대 100개이므로 교환횟수는 1000을 넘지 않을것
    min_cnt = 1000
    dfs(0,0)
    print('#{} {}'.format(tc, min_cnt)) 
```     
- 현재 번호에서 갈수 있는 정류장이 도착지점을 넘어선다면, 끝까지 갈 수 있는 것이므로 종료해야하는데, 이 부분에 대해선 가지치기하지 않아서 계속 시간초과 발생    

<hr>    
</br><br>   

### 1240. 단순 2진 암호코드    
```python   
check = {'0001101':0, '0011001':1, '0010011':2, '0111101':3, '0100011':4, '0110001':5,
         '0101111':6, '0111011':7, '0110111':8, '0001011':9}


def find_start():
    for i in range(N):
        for j in range(M-1,-1,-1):
            if board[i][j] == '1':
                return [i,j]

def vaild(n):
    ans_2 = ans_1 = 0
    # 문제에선 홀수자리의 합이지만 인덱스가 0부터 시작이므로 짝수자리의 합 x 3 + 홀수자리합 + 검증코드로 작성
    for i in range(len(n)-1):
        if i % 2 == 0 :
            ans_2 += n[i]
        else:
            ans_1 += n[i]
    ans = ans_2 * 3 + ans_1 + n[-1]
    if ans % 10 ==0:
        return True
    else:
        return False



T = int(input())
for tc in range(1,T+1):
    N,M = map(int,input().split())
    board = [input() for _ in range(N)]
    num = [[] for _ in range(8)]
    c = 0
    start = find_start()
    for k in range(start[1], start[1]-56, -7):
        num[c] = board[start[0]][k-6:k+1]
        c += 1
    # 뒤에서부터 집어넣었으므로 전체 순서 다시 뒤집기
    num.reverse()
    result = []
    for n in num:
        result.append(check[n])
    if vaild(result) is True:
        ans = sum(result)
    else:
        ans = 0


    print('#{} {}'.format(tc,ans)) 
```    

<hr>    
<br><br>     

### 1220. Magnetic    
```python   
for tc in range(1,11):    
    N = int(input())    # 한 변의 길이    
    board = [list(map(int,input().split())) for _ in range(N)]  # 테이블 위 상태 , 1은 N , 2는 S , 윗부분 N, 아랫부분 S    
    stack = [[] for _ in range(N)]
    cnt = 0
    for i in range(N):
        flag = False
        for j in range(N):
            if board[j][i] == 1 and flag is False:          # 위가 N극이므로 N극(1)이 먼저 나와야지만 빨려들어가지 않는다
                flag = True
            elif board[j][i] == 2 and flag is True:         # S극이어도, flag가 트루면, 이미 N극을 만난것이므로 교착상태
                cnt += 1
                flag = False
    print('#{} {}'.format(tc,cnt))  
```    
- flag 변수를 T/F 값으로 체크하는대신 0/1로 체크하는 방법도 가능    
- 아니면 아래처럼 스택에 넣고 빼는 방식으로도 가능   
    ```python    
    T = 10 
    for tc in range(1, T+1):    
    N = int(input())
    a = [list(map(int, input().split())) for _ in range(N)]

    cnt = 0
    for j in range(N):
        r, c = 0, j
        stack = []

        while r < N:
            if not stack and a[r][c] == 1:
                stack.append(1)
            elif stack and a[r][c] == 2:
                cnt += stack.pop()
            r += 1

    print("#{} {}".format(tc, cnt))    
    ```   
    
<hr>   
</br></br>     

