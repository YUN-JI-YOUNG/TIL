# D3 난이도    
</br>   

## 정답 코드   

### 5178. 노드의 합

```python
T = int(input())

for tc in range(1,T+1):
    N,M,L = map(int,input().split())
    node = [0] * (N+1)
    for k in range(M):
        idx, n = map(int,input().split())
        node[idx] = n
    for m in range(N//2,0,-1):
        if node[m]==0:
            if (m*2 <= N) and (m*2+1 <=N):
                node[m] = node[m*2] + node[m*2+1]
            elif m*2+1 > N:
                node[m] = node[m*2]
    print('#{} {}'.format(tc, node[L]))
```

</br>   
<hr>   

### 1244. 최대상금   
   
```python   
import sys
sys.stdin = open('input.txt')

def find_big(li,n,small):
    max_idx = n-1
    for k in range(n-1,small,-1):
        if board[max_idx] < board[k]:
            max_idx = k
    return max_idx

def find_small(li,n,big):
    min_idx = 0
    for j in range(big):
        if board[min_idx] > board[j]:
            min_idx = j
    return min_idx


T = int(input())
for tc in range(1,T+1):
    N = list(input().split())
    trade = int(N[-1])
    board = list(N[0])
    n = len(board)
    # 뒤에서 찾을땐 가장 큰수, 앞에서 찾을땐 가장 작은수 -> 그렇게 교환
    b, s = n,0
    # 교환 횟수가 남아있다면
    while trade:
        # 탐색 시작지점 s가 마지막인덱스가 아니라면
        if s <= n-1:
            # 뒤에서부터 s까지 탐색하면서 가장 큰 값찾기 -> 큰 값은 앞에 있을 수록 좋으므로, 가장 뒤에 있는 값을 옮기기 위해서
            b = find_big(board,n,s-1)
            # 가장 큰 값이 숫자판에서 중복없이 있다면
            if board.count(board[b]) == 1:
                # 찾은 값의 인덱스가 현재 시작지점과 같지 않다면
                if s != b :
                    # 교환, 교환횟수 - 1, 시작지점 +1
                    board[b], board[s] = board[s], board[b]
                    trade -= 1
                    s += 1
                # 찾은 값이 인덱스가 현재 시작지점과 같다면, 교환해봤자 제자리걸음이므로 교환없이 시작지점만 + 1
                else:
                    s += 1
            # 가장 큰 값이 숫자판에서 중복이라면
            else:
                # 맨 앞에서부터 해당 값의 인덱스까지만 탐색하면서 가장 작은 값 찾기 -> 작은 값은 뒤에 있을 수록 좋으므로 가장 앞에 있는 작은 값을 옮기기 위해서
                m = find_small(board, n, b)
                # 가장 작은 값과 찾은 큰 값 교환 , 교환 횟수 - 1
                board[m], board[b] = board[b], board[m]
                trade -= 1
        # 탐색 시작지점 s가 마지막인덱스라면, 크기에따른 교환은 모두 끝낸것이므로 교환횟수를 모두 소모할때까지 제일 작은 값들인 마지막 두 값을 무한히 교환
        else:
            board[n-1], board[n-2] = board[n-2], board[n-1]
            trade -= 1

    print('#{} {}'.format(tc, ''.join(board)))   
```   

</br>    
<hr>   

### 5248. 그룹 나누기   
```python  
def dfs(n):
    visited[n] = 1
    res.append(n)
    for w in arrList[n]:
        if visited[w] == 0:
            visited[w] = 1
            dfs(w)
        else:
            for k in result:
                if w in k:
                    k.append(n)
                    res.clear()

T = int(input())
for tc in range(1,T+1):
    N, M = map(int,input().split())
    li = list(map(int,input().split()))
    arrList = [[] for _ in range(N+1)]
    check = set()
    for i in range(M):
        a1, a2 = li[i*2], li[i*2+1]
        arrList[a1].append(a2)
        arrList[a2].append(a1)
        check.add(a1)
        check.add(a2)
    visited = [0] * (N + 1)
    cnt = N - len(check)
    result = []
    for k in check:
        if visited[k] : continue
        res = []
        dfs(k)
        if res:
            result.append(res)
    print('#{} {}'.format(tc,cnt+len(result))) 
```   
- dfs 재귀 이용하여 풀이    

</br>   
<hr>    
   
### 2814. 최장 경로   
```python  
def dfs(n):
    global res
    visited[n] = 1
    res += 1
    result.append(res)
    for w in arrList[n]:
        if visited[w] == 0 :
            dfs(w)
            visited[w] = 0
            res -= 1


T = int(input())

for tc in range(1,T+1):
    N,M = map(int,input().split())
    arrList = [[] for _ in range(N+1)]
    for _ in range(M):
        x,y = map(int,input().split())
        arrList[x].append(y)
        arrList[y].append(x)
    result = []
    for i in range(1,N+1):
        res = 0
        visited = [0] * (N + 1)
        dfs(i)

    print('#{} {}'.format(tc, max(result)))
```   
- bfs 로 구현할 시 오류 발생   

<br>  
<hr>    

### 5209. 최소 생산 비용     
```python   
def perm(n,k,ans):
    global min_cost
    if ans > min_cost:
        return
    if k == n:
        if ans < min_cost:
            min_cost = ans
    else:
        for i in range(n):
            if not used[i]:
                p[k] = arr[i]
                used[i] = 1
                perm(n,k+1, ans+cost[k][p[k]])
                used[i] = 0


T= int(input())
for tc in range(1,T+1):
    N = int(input())
    cost = [list(map(int,input().split())) for _ in range(N)]
    p = [0] * N
    arr = [i for i in range(N)]
    used = [0] * (N+1)
    min_cost = 99 * (N ** 2)
    perm(N,0,0)
    print('#{} {}'.format(tc,min_cost))
```   
<hr>   
</br>     

### 5204. 병합정렬    
```python    

def quick(l,L,R):
    if L < R:
        s = partition(l,L,R)
        quick(l,L,s-1)
        quick(l,s+1,R)

def partition(l,L,R):
    # 피봇값을 제일 왼쪽값으로 설정
    p = l[L]
    i,j = L,R
    while i <= j :
        while i <= j and l[i] <= p:
            i += 1
        while i <= j and l[j] >= p :
            j -= 1
        if i <= j :
            l[i], l[j] = l[j], l[i]
    l[L], l[j] = l[j], l[L]
    return j

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    lst = list(map(int,input().split()))
    quick(lst, 0, N-1)
    print('#{} {}'.format(tc,lst[N//2]))
```     


</hr>   
</br>   

### 5205. 퀵정렬    
```python   
def quick(l,L,R):
    if L < R:
        s = partition(l,L,R)
        quick(l,L,s-1)
        quick(l,s+1,R)

def partition(l,L,R):
    # 피봇값을 제일 왼쪽값으로 설정
    p = l[L]
    i,j = L,R
    while i <= j :
        while i <= j and l[i] <= p:
            i += 1
        while i <= j and l[j] >= p :
            j -= 1
        if i <= j :
            l[i], l[j] = l[j], l[i]
    l[L], l[j] = l[j], l[L]
    return j

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    lst = list(map(int,input().split()))
    quick(lst, 0, N-1)
    print('#{} {}'.format(tc,lst[N//2]))
```    
</br>  
<hr>      

### 5189. 전자카트     
```python    
def perm(n,m,k):
    global arr, p
    if k == n:
        if p[0] == 1:
            start.append(p[:])
        elif p[1] ==1:
            end.append(p[:])
        else:
            li.append(p[:])
    else:
        for i in range(m):
            if not used[i]:
                p[k] = arr[i]
                used[i] = 1
                perm(n,m,k+1)
                used[i] = 0

def search(cnt, sta, add):
    global ans
    si,sj = sta

    if cnt == N-1:
        add += board[sj][1]
        if ans > add:
            ans = add
        return
    else:
        for l in li:
            if l[0] == sj and not used[l[1]]:
                ls,le = l
                if board[ls][le] != 0 :
                    temp = board[ls][le]
                    board[ls][le] = 0
                    used[ls] = 1
                    search(cnt+1, l, add + temp)
                    board[ls][le] = temp
                    used[ls] = 0

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [[0] * (N+1)] + [[0] + list(map(int,input().split())) for _ in range(N)]
    used = [0]*(N+1)
    arr = list(range(1,N+1))
    li = []
    end = []
    start = []
    p = [0] * 2
    ans = 9999999999999
    perm(2,N,0)
    used = [0] * (N+1)
    for s in start:
        si, sj = s
        a = board[si][sj]
        board[si][sj] = 0
        search(1, s, a)
    print('#{} {}'.format(tc,ans))
```    
- 순열 + 재귀 이용      

<hr>    
<br><br>   

### 5201. 컨테이너 운반     
```python    
def add():
    # 최종무게 ans를 0으로 초기화
    ans = 0
    # 트럭 중량에 대해 반복문 순회
    for max_weight in t:
        # 컨테이너 무게에 대해 반복을 돌면서
        for weight in w:
            # 컨테이너 무게가 현재 트럭의 중량보다 작거나 같으면 최종 무게 ans에 추가
            if weight <= max_weight:
                ans += weight
                # 이번 트럭에 컨테이너를 실은 것이므로 해당 컨테이너 무게는 배열에서 삭제
                w.remove(weight)
                # 트럭 1대당 1개의 컨테이너만 실을 수 있으므로 실을 컨테이너 찾았으면 break
                break
    return ans


T = int(input())
for tc in range(1,T+1):
    N, M = map(int,input().split())     # 컨테이너 , 트럭 수
    # 중량이 큰 트럭에 무거운 무게를 실어야 효율적이므로 트럭 중량과 컨테이너 무게 배열 모두 내림차순 정렬
    w = sorted(list(map(int,input().split())),reverse=True)  # 컨테이너 무게 내림차순정렬
    t = sorted(list(map(int,input().split())),reverse=True)  # 트럭 중량 내림차순 정렬
    print('#{} {}'.format(tc,add()))
```    

<hr>   
<br><br>    
