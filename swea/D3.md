# D3 난이도    
</br>   

## 정답 코드   

### 5178. 노드의 합

```python
T = int(input())

for tc in range(1,T+1):
    N,M,L = map(int,input().split())
    node = [0] * (N+1)
    for k in range(M):
        idx, n = map(int,input().split())
        node[idx] = n
    for m in range(N//2,0,-1):
        if node[m]==0:
            if (m*2 <= N) and (m*2+1 <=N):
                node[m] = node[m*2] + node[m*2+1]
            elif m*2+1 > N:
                node[m] = node[m*2]
    print('#{} {}'.format(tc, node[L]))
```

</br>   
<hr>   

### 1244. 최대상금   
   
```python   
import sys
sys.stdin = open('input.txt')

def find_big(li,n,small):
    max_idx = n-1
    for k in range(n-1,small,-1):
        if board[max_idx] < board[k]:
            max_idx = k
    return max_idx

def find_small(li,n,big):
    min_idx = 0
    for j in range(big):
        if board[min_idx] > board[j]:
            min_idx = j
    return min_idx


T = int(input())
for tc in range(1,T+1):
    N = list(input().split())
    trade = int(N[-1])
    board = list(N[0])
    n = len(board)
    # 뒤에서 찾을땐 가장 큰수, 앞에서 찾을땐 가장 작은수 -> 그렇게 교환
    b, s = n,0
    # 교환 횟수가 남아있다면
    while trade:
        # 탐색 시작지점 s가 마지막인덱스가 아니라면
        if s <= n-1:
            # 뒤에서부터 s까지 탐색하면서 가장 큰 값찾기 -> 큰 값은 앞에 있을 수록 좋으므로, 가장 뒤에 있는 값을 옮기기 위해서
            b = find_big(board,n,s-1)
            # 가장 큰 값이 숫자판에서 중복없이 있다면
            if board.count(board[b]) == 1:
                # 찾은 값의 인덱스가 현재 시작지점과 같지 않다면
                if s != b :
                    # 교환, 교환횟수 - 1, 시작지점 +1
                    board[b], board[s] = board[s], board[b]
                    trade -= 1
                    s += 1
                # 찾은 값이 인덱스가 현재 시작지점과 같다면, 교환해봤자 제자리걸음이므로 교환없이 시작지점만 + 1
                else:
                    s += 1
            # 가장 큰 값이 숫자판에서 중복이라면
            else:
                # 맨 앞에서부터 해당 값의 인덱스까지만 탐색하면서 가장 작은 값 찾기 -> 작은 값은 뒤에 있을 수록 좋으므로 가장 앞에 있는 작은 값을 옮기기 위해서
                m = find_small(board, n, b)
                # 가장 작은 값과 찾은 큰 값 교환 , 교환 횟수 - 1
                board[m], board[b] = board[b], board[m]
                trade -= 1
        # 탐색 시작지점 s가 마지막인덱스라면, 크기에따른 교환은 모두 끝낸것이므로 교환횟수를 모두 소모할때까지 제일 작은 값들인 마지막 두 값을 무한히 교환
        else:
            board[n-1], board[n-2] = board[n-2], board[n-1]
            trade -= 1

    print('#{} {}'.format(tc, ''.join(board)))   
```   

</br>    
<hr>   

### 5248. 그룹 나누기   
```python  
def dfs(n):
    visited[n] = 1
    res.append(n)
    for w in arrList[n]:
        if visited[w] == 0:
            visited[w] = 1
            dfs(w)
        else:
            for k in result:
                if w in k:
                    k.append(n)
                    res.clear()

T = int(input())
for tc in range(1,T+1):
    N, M = map(int,input().split())
    li = list(map(int,input().split()))
    arrList = [[] for _ in range(N+1)]
    check = set()
    for i in range(M):
        a1, a2 = li[i*2], li[i*2+1]
        arrList[a1].append(a2)
        arrList[a2].append(a1)
        check.add(a1)
        check.add(a2)
    visited = [0] * (N + 1)
    cnt = N - len(check)
    result = []
    for k in check:
        if visited[k] : continue
        res = []
        dfs(k)
        if res:
            result.append(res)
    print('#{} {}'.format(tc,cnt+len(result))) 
```   
- dfs 재귀 이용하여 풀이    

</br>   
<hr>    
   
### 2814. 최장 경로   
```python  
def dfs(n):
    global res
    visited[n] = 1
    res += 1
    result.append(res)
    for w in arrList[n]:
        if visited[w] == 0 :
            dfs(w)
            visited[w] = 0
            res -= 1


T = int(input())

for tc in range(1,T+1):
    N,M = map(int,input().split())
    arrList = [[] for _ in range(N+1)]
    for _ in range(M):
        x,y = map(int,input().split())
        arrList[x].append(y)
        arrList[y].append(x)
    result = []
    for i in range(1,N+1):
        res = 0
        visited = [0] * (N + 1)
        dfs(i)

    print('#{} {}'.format(tc, max(result)))
```   
- bfs 로 구현할 시 오류 발생   

<br>  
<hr>    
