# D4 난이도    
</br>   

## 정답 코드   

### 1232. 사칙연산

```python
def emu(n):
    li = node[:]
    if li[n] == '/':
        li[n] = float(li[left[n]]) / float(li[right[n]])
    elif node[n] == '*':
        li[n] = float(li[left[n]]) * float(li[right[n]])
    elif node[n] == '+':
        li[n] = float(li[left[n]]) + float(li[right[n]])
    elif node[n] == '-':
        li[n] = float(li[left[n]]) - float(li[right[n]])
    return li

for tc in range(1,11):
    N = int(input())
    node = [0] * (N+1)
    left = [0] * (N+2)
    right = [0] * (N+2)
    for _ in range(N):
        input_li = input().split()
        idx = int(input_li[0])
        if input_li[1].isdigit():
            node[idx] = int(input_li[1])
        else:
            node[idx] = input_li[1]
            left[idx] = int(input_li[2])
            right[idx] = int(input_li[3])
    for m in range(N,0,-1):
        if type(node[m]) == str:
            node = emu(m)

    print('#{} {}'.format(tc, int(node[1])))
    
```

</br>   

###### 자식노드가 항상 *2, *2+1 형태가 아니여서 틀린 답
```python
def emu(n):
    if node[n] == '/':
        node[n] = float(node[n*2]) / float(node[n*2+1])
    elif node[n] == '*':
        node[n] = float(node[n*2]) * float(node[n*2+1])
    elif node[n] == '+':
        node[n] = float(node[n*2]) + float(node[n*2+1])
    elif node[n] == '-':
        node[n] = float(node[n*2]) - float(node[n*2+1])


for tc in range(1,11):
    N = int(input())
    node = [0] * (N+1)
    left = [0] * (N+1)
    right = [0] * (N+1)
    for _ in range(N):
        input_li = input().split()
        idx = int(input_li[0])
        if input_li[1].isdigit():
            cnt = int(input_li[1])
        else:
            cnt = input_li[1]
        node[idx] = cnt
        if idx == 1:
            left[idx] = cnt
        else:
            if idx % 2 :
                right[idx] = cnt
            else:
                left[idx] = cnt
    for m in range(N//2,0,-1):
        if type(node[m]) == str:
            if (m*2 <= N) and (m*2+1 <=N):
                emu(m)
    print(int(node[1]))
```
</br>   

<hr>    

### 1486. 장훈이의 높은 선반    
  
```python    

#가지치기 X
def powerset(n):
    global hei_sum, N
    for i in range(1<<N):
        for j in range(N):
            if i & (1<<j):
                pow[i].append(height[j])
        ans = sum(pow[i])
        if ans >= B and (hei_sum > ans):
            hei_sum = ans

T = int(input())
for tc in range(1,T+1):
    N, B = map(int,input().split())
    height = sorted(list(map(int,input().split())))
    hei_sum = 987654321
    pow = [[] for _ in range(1<<N)]
    powerset(height)
    print('#{} {}'.format(tc,hei_sum-B))
```   

</br>   

<hr>   

### 1861 정사각형 방   

```python   
def check(i,j):
    global cnt
    # 22번 케이스 200*200개 출력하려면 가지치기 필요..어떻게 해야하려나

    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if 0 <= ni < N and 0 <= nj < N:
            if board[i][j] + 1 == board[ni][nj]:
                cnt += 1
                check(ni,nj)
    return



T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [list(map(int,input().split())) for _ in range(N)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    max_cnt = 0
    max_idx = 987654321
    for i in range(N):
        for j in range(N):
            # 현재 방 1개에서 시작
            cnt = 1
            check(i,j)
            if max_cnt == cnt:
                if max_idx > board[i][j]:
                    max_idx = board[i][j]
            if max_cnt < cnt:
                max_cnt = cnt
                max_idx = board[i][j]

    print('#{} {} {}'.format(tc,max_idx, max_cnt))   
```  
```python    
# 다른방법 1 -> 1번에서 2번으로 갈 수 있으면 배열[1] =1 , 3번에서 4번으로 갈 수 있으면 배열[3] = 1 .. 이런식으로 배열을 하나 만들고,
# 뒤에서부터 순회하면서 1이나오면, 0이 나올때까지 cnt +1 -> 최대값보다 크거나 같으면 최대값 갱신하고 마지막으로 1이 나온 번호를 i에 저장하고, 갈 수 있는 방 갯수는, 본인 방도 포함해야하므로 cnt += 1
# 뒤에서부터 순회하므로 최대값이 같더라도, 순회끝나면 그 중 작은 번호가 i에 저장되게 됨


# 다른방법 2 -> 2차원배열을 뒤에서부터 순회하면서 pos배열에 각 방번호의 좌표(i,j) 추가 -> dis =[1]*(N*N+1) 로 1로 초기화
# 그러면 pos[1]은 1번 방의 좌표 등이 들어갈 것이고, pos 배열을 순회하면서 (1번방 좌표에서 2번방 좌표가 상하좌우로 갈 수있는 경우라면
# 즉, 두 방 좌표의 차이가 (1,0), (0,1), (-1,0), (0,-1) 안에 존재한다면, 갈 수 있는 것이므로 dis[i-1] = dis[i]+1 (다음 방번호의 거리 + 1)만큼 추가 (뒤에서부터 순회하므로)
# 그러면서 최대값보다 dis[i-1]가 더 크다면, 최댓값을 갱신하고, 방번호도 갱신
```  
<hr>   
</br>   

