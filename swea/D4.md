# D4 난이도    
</br>   

## 정답 코드   

### 1232. 사칙연산

```python
def emu(n):
    li = node[:]
    if li[n] == '/':
        li[n] = float(li[left[n]]) / float(li[right[n]])
    elif node[n] == '*':
        li[n] = float(li[left[n]]) * float(li[right[n]])
    elif node[n] == '+':
        li[n] = float(li[left[n]]) + float(li[right[n]])
    elif node[n] == '-':
        li[n] = float(li[left[n]]) - float(li[right[n]])
    return li

for tc in range(1,11):
    N = int(input())
    node = [0] * (N+1)
    left = [0] * (N+2)
    right = [0] * (N+2)
    for _ in range(N):
        input_li = input().split()
        idx = int(input_li[0])
        if input_li[1].isdigit():
            node[idx] = int(input_li[1])
        else:
            node[idx] = input_li[1]
            left[idx] = int(input_li[2])
            right[idx] = int(input_li[3])
    for m in range(N,0,-1):
        if type(node[m]) == str:
            node = emu(m)

    print('#{} {}'.format(tc, int(node[1])))
    
```

</br>   

###### 자식노드가 항상 *2, *2+1 형태가 아니여서 틀린 답
```python
def emu(n):
    if node[n] == '/':
        node[n] = float(node[n*2]) / float(node[n*2+1])
    elif node[n] == '*':
        node[n] = float(node[n*2]) * float(node[n*2+1])
    elif node[n] == '+':
        node[n] = float(node[n*2]) + float(node[n*2+1])
    elif node[n] == '-':
        node[n] = float(node[n*2]) - float(node[n*2+1])


for tc in range(1,11):
    N = int(input())
    node = [0] * (N+1)
    left = [0] * (N+1)
    right = [0] * (N+1)
    for _ in range(N):
        input_li = input().split()
        idx = int(input_li[0])
        if input_li[1].isdigit():
            cnt = int(input_li[1])
        else:
            cnt = input_li[1]
        node[idx] = cnt
        if idx == 1:
            left[idx] = cnt
        else:
            if idx % 2 :
                right[idx] = cnt
            else:
                left[idx] = cnt
    for m in range(N//2,0,-1):
        if type(node[m]) == str:
            if (m*2 <= N) and (m*2+1 <=N):
                emu(m)
    print(int(node[1]))
```
</br>   

<hr>    

### 1486. 장훈이의 높은 선반    
  
```python    

#가지치기 X
def powerset(n):
    global hei_sum, N
    for i in range(1<<N):
        for j in range(N):
            if i & (1<<j):
                pow[i].append(height[j])
        ans = sum(pow[i])
        if ans >= B and (hei_sum > ans):
            hei_sum = ans

T = int(input())
for tc in range(1,T+1):
    N, B = map(int,input().split())
    height = sorted(list(map(int,input().split())))
    hei_sum = 987654321
    pow = [[] for _ in range(1<<N)]
    powerset(height)
    print('#{} {}'.format(tc,hei_sum-B))
```   

</br>   

<hr>   

### 1861. 정사각형 방   

```python   
def check(i,j):
    global cnt
    # 22번 케이스 200*200개 출력하려면 가지치기 필요..어떻게 해야하려나

    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if 0 <= ni < N and 0 <= nj < N:
            if board[i][j] + 1 == board[ni][nj]:
                cnt += 1
                check(ni,nj)
    return



T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [list(map(int,input().split())) for _ in range(N)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    max_cnt = 0
    max_idx = 987654321
    for i in range(N):
        for j in range(N):
            # 현재 방 1개에서 시작
            cnt = 1
            check(i,j)
            if max_cnt == cnt:
                if max_idx > board[i][j]:
                    max_idx = board[i][j]
            if max_cnt < cnt:
                max_cnt = cnt
                max_idx = board[i][j]

    print('#{} {} {}'.format(tc,max_idx, max_cnt))   
```  
```python    
# 다른방법 1 -> 1번에서 2번으로 갈 수 있으면 배열[1] =1 , 3번에서 4번으로 갈 수 있으면 배열[3] = 1 .. 이런식으로 배열을 하나 만들고,
# 뒤에서부터 순회하면서 1이나오면, 0이 나올때까지 cnt +1 -> 최대값보다 크거나 같으면 최대값 갱신하고 마지막으로 1이 나온 번호를 i에 저장하고, 갈 수 있는 방 갯수는, 본인 방도 포함해야하므로 cnt += 1
# 뒤에서부터 순회하므로 최대값이 같더라도, 순회끝나면 그 중 작은 번호가 i에 저장되게 됨


# 다른방법 2 -> 2차원배열을 뒤에서부터 순회하면서 pos배열에 각 방번호의 좌표(i,j) 추가 -> dis =[1]*(N*N+1) 로 1로 초기화
# 그러면 pos[1]은 1번 방의 좌표 등이 들어갈 것이고, pos 배열을 순회하면서 (1번방 좌표에서 2번방 좌표가 상하좌우로 갈 수있는 경우라면
# 즉, 두 방 좌표의 차이가 (1,0), (0,1), (-1,0), (0,-1) 안에 존재한다면, 갈 수 있는 것이므로 dis[i-1] = dis[i]+1 (다음 방번호의 거리 + 1)만큼 추가 (뒤에서부터 순회하므로)
# 그러면서 최대값보다 dis[i-1]가 더 크다면, 최댓값을 갱신하고, 방번호도 갱신
```  
<hr>   
</br>   

### 4366. 정식이의 은행업무    

```python  
# 2진수 계산
def cal_binary(n):
    ans = 0
    li = n[::-1]
    for i in range(len(n)):
        ans += (2**i) * li[i]
    return ans

# 3진수 계산
def cal_trit(n):
    ans = 0
    li = n[::-1]
    for i in range(len(n)):
        ans += (3**i) * li[i]
    return ans


T = int(input())
for tc in range(1,T+1):
    binary = list(map(int,input()))
    trit = list(map(int,input()))
    i = j = 0

    # 가능한 경우의 수를 모두 담을 리스트 reb,ret
    reb = [0] * len(binary)
    ret = [0] * (2*len(trit))

    # 무조건 1자리가 틀리다고 하였으므로 2진수에서 틀린 자릿수 i
    while i < len(binary):
        # 원래 값을 temp에 저장해두고, 바꾼 후 계산하여 reb 리스트에 담고, 다시 원래 값 복구 -> 다음 자리수 변경 반복
        temp = binary[i]
        binary[i] = (binary[i]+1) % 2
        reb[i] = cal_binary(binary)
        binary[i] = temp
        i += 1

    # 3진수는 1,2,3에서 바뀌므로 한 자리에서 바뀔 수 있는 경우가 2가지 존재
    # -> 자릿수 인덱스와 ret 배열에 넣을 인덱스에서 차이가 생겨서, 배열에 넣을 인덱스는 새로운 인덱스 m 사용
    m = 0

    # 3진수에서 틀린 자릿수 j
    while j < len(trit):
        temp2 = trit[j]
        for k in range(1,3):
            trit[j] = (trit[j]+1) % 3
            ret[m] = cal_trit(trit)
            m += 1
        # 해당 자릿수에서 바꿀 수 있는 경우를 반복문을 통해 모두 배열에 넣고, 다시 원래값 복구 후 다음 자릿수 변경 반복
        trit[j] = temp2
        j += 1
    result = 0

    # 가능한 수를 모두 배열에 담았으므로, 배열을 순회하며 같은 값이 존재하면 result에 담고 break
    for i in range(len(ret)):
        for j in range(len(reb)):
            if ret[i] == reb[j]:
                result = ret[i]
                break
        if result:
            break
    print('#{} {}'.format(tc,result))
```   
</br>   
<hr>   

### 2819. 격자판의 숫자 이어붙이기    

```python  
def paste(i,j, ans):
    global cnt
    if len(ans) == 7:
        result.add(ans)
        return
    while i < 4 and j < 4:
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 0 <= ni < 4 and 0 <= nj < 4:
                paste(ni,nj,ans+str(board[ni][nj]))
                ni -= di[k]
                nj -= dj[k]
                i = ni
                j = nj
        return
    return

T = int(input())
for tc in range(1,T+1):
    board = [list(map(int,input().split())) for _ in range(4)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    cnt = 0
    result = set()
    for i in range(4):
        for j in range(4):
            paste(i,j,str(board[i][j]))
    print('#{} {}'.format(tc,len(result)))
```  

#### 다른방법 - 리스트 활용   

```python   
def paste(i,j, ans):
    global cnt
    if len(ans) == 7:
        if ans not in result:
            result.append(ans)
            cnt += 1
        return
    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if 0 <= ni < 4 and 0 <= nj < 4:
            paste(ni,nj,ans+str(board[ni][nj]))

T = int(input())
for tc in range(1,T+1):
    board = [list(map(int,input().split())) for _ in range(4)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    cnt = 0
    result = []
    for i in range(4):
        for j in range(4):
            paste(i,j,str(board[i][j]))
    print('#{} {}'.format(tc,cnt))
```   
</br>   
<hr>   

### 1249. 보급로    
```python   
import collections

def bfs(n):
    que = collections.deque()
    que.append(n)
    arr[n[0]][n[1]] = 0
    while que:
        x,y = que.popleft()
        for k in range(4):
            nx = x + di[k]
            ny = y + dj[k]
            if 0<= nx < N and 0<= ny < N:
                if arr[nx][ny] > arr[x][y] + board[nx][ny]:
                    arr[nx][ny] = arr[x][y] + board[nx][ny]
                    que.append([nx,ny])

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [list(map(int,input())) for _ in range(N)]
    INF = 987654321
    arr = [[INF] * (N) for _ in range(N)]
    di = [-1,1,0,0]
    dj = [0,0,-1,1]
    bfs([0,0])
    print('#{} {}'.format(tc,arr[N-1][N-1]))
```     
</br>   
<hr>    

### 1251. 하나로    
```python   
def prim(n):
    dist[n] = 0
    visited = [0] *(N+1)
    for _ in range(N+1):
        minV = INF
        for i in range(N):
            if visited[i] == 0 and minV > dist[i]:
                w = i
                minV = dist[i]
        visited[w] = 1
        for v in range(N):
            if visited[v] == 0 and arr[w][v] :
                dist[v] = min(dist[v], arr[w][v])

T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    x_board = list(map(int, input().split()))
    y_board = list(map(int, input().split()))
    E = float(input())
    INF = 987654321987654321
    arr = [[0] * N for _ in range(N)]
    for i in range(N-1):
        for j in range(i + 1, N):
            L = (x_board[i] - x_board[j]) ** 2 + (y_board[i] - y_board[j]) ** 2
            w = float(L * E)
            arr[i][j] = w
            arr[j][i] = w
    dist = [INF] * N
    prim(0)
    print('#{} {}'.format(tc, round(sum(dist))))
```    
</br>   
<hr>     

### 7465. 창용 마을 무리의 개수     

```python   
def find_set2(n):
    if p[n] != n :
        p[n] = find_set2(p[n])
    return p[n]

T = int(input())
for tc in range(1,T+1):
    N, M =map(int,input().split())
    p = [i for i in range(N+1)]
    for k in range(M):
        s, e = map(int,input().split())
        p[find_set2(s)] = find_set2(e)
    res = set()
    for v in range(1,N+1):
        res.add(find_set2(v))
    print('#{} {}'.format(tc,len(res)))
```    
- 서로소 집합(disjoint sets) 이용   

</br>   
<hr>          

### 5249. 최소 신장 트리   
```python  
def find_set(n):
    while p[n] != n :
        n = p[n]
    return n
T = int(input())
for tc in range(1,T+1):
    V, E = map(int,input().split())
    arr = []
    for i in range(E):
        n1,n2,w = map(int,input().split())
        arr.append([w,n1,n2]) 
    arr.sort()
    p = [i for i in range(V+1)]
    cnt = res = 0
    for w,n1,n2 in arr :
        if find_set(n1) != find_set(n2):
            cnt += 1
            res += w
            p[find_set(n1)] = find_set(n2)
        if cnt == V:
            break
    print('#{} {}'.format(tc,res))
```  
- 서로소 집합 이용22    

</br>  
<hr>   

### 1865. 동철이의 일 분배     
```python   
def perm(n,k,ans):
    global max_per
    if ans == 0:
        return
    if ans < max_per:
        return
    if k == n:
        if ans > max_per:
            max_per = ans
    else:
        for i in range(k, n):
            arr[k], arr[i] = arr[i], arr[k]
            perm(n,k+1,ans*percent[k-1][arr[k]])
            arr[k], arr[i] = arr[i], arr[k]


T = int(input())
for tc in range(1,T+1):
    N = int(input())
    percent = [list(map(int,input().split())) for _ in range(N)]
    for i in range(N):
        for j in range(N):
            percent[i][j] /= 100
    max_per = 0
    arr = [i for i in range(N)]
    perm(N,0,1)
    print('#{} {:06.6f}'.format(tc,max_per*100))
```   
- 다른 풀이 (처음엔 시간초과 났었는데, 최대값을 갱신하고 리턴을 안해서 시간초과난거였다..)    

```python   
def perm(n,k,ans):
    global max_per
    if ans == 0:
        return
    if ans <= max_per:
        return
    if k == n:
        if ans > max_per:
            max_per = ans
        return
    else:
        for i in range(N):
            if not used[i]:
                p[k] = arr[i]
                used[i] = 1
                perm(n,k+1,ans*percent[k][p[k]])
                used[i] = 0

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    percent = [list(map(int,input().split())) for _ in range(N)]
    for i in range(N):
        for j in range(N):
            percent[i][j] /= 100
    max_per = 0
    used = [0] * (N+1)
    p = [0] * N
    arr = [i for i in range(N)]
    perm(N,0,1)
    print('#{} {:06.6f}'.format(tc,max_per*100))
```     

### 5247. 연산     
```python    
import collections

oper = [['*',2],['+',1],['-',1],['-',10]]

def bfs(n):
    global result, size, end
    que = collections.deque([])
    que.append(n)
    while que:
        res,cnt = que.popleft()
        if cnt > result:
            continue
        else:
            for i in range(4):
                op, n = oper[i]
                res1 = res2 = res3 = 0
                if op == '+':
                    res1 = res+n
                    if res1 < size and visited[res1] == 0 :
                        que.append([res1,cnt+1])
                        visited[res1] = 1
                elif op == '-':
                    res2 = res-n
                    if 0 < res2 < size and visited[res2] == 0:
                        que.append([res2,cnt+1])
                        visited[res2] = 1
                elif op == '*':
                    res3 = res*n
                    if res3 < size and visited[res3] == 0:
                        que.append([res3,cnt+1])
                        visited[res3] = 1
                if res1 == end or res2 == M or res3 == M :
                    result = min(result,cnt+1)

T = int(input())
for tc in range(1,T+1):
    N,M = map(int,input().split())
    start = min(N,M)
    end = max(M,N)
    result = 987654321
    size = 1000000
    visited =[0] * 1000001           # 방문표시안하면 메모리 터짐
    bfs([start,0])
    print('#{} {}'.format(tc,result))  
```    
- 하나의 경우에서 각 연산에 대한 가지를 뻗어나가야하므로 bfs     
- 재귀 dfs로 할 경우 시간초과가 발생하는데, 백트레킹 열심히 하면 될것같기도 하지만 너무 복잡할 것 같아 bfs로 변경     

<hr>   
</br></br>     



