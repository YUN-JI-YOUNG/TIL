# D4 난이도    
</br>   

## 정답 코드   

### 1232. 사칙연산

```python
def emu(n):
    li = node[:]
    if li[n] == '/':
        li[n] = float(li[left[n]]) / float(li[right[n]])
    elif node[n] == '*':
        li[n] = float(li[left[n]]) * float(li[right[n]])
    elif node[n] == '+':
        li[n] = float(li[left[n]]) + float(li[right[n]])
    elif node[n] == '-':
        li[n] = float(li[left[n]]) - float(li[right[n]])
    return li

for tc in range(1,11):
    N = int(input())
    node = [0] * (N+1)
    left = [0] * (N+2)
    right = [0] * (N+2)
    for _ in range(N):
        input_li = input().split()
        idx = int(input_li[0])
        if input_li[1].isdigit():
            node[idx] = int(input_li[1])
        else:
            node[idx] = input_li[1]
            left[idx] = int(input_li[2])
            right[idx] = int(input_li[3])
    for m in range(N,0,-1):
        if type(node[m]) == str:
            node = emu(m)

    print('#{} {}'.format(tc, int(node[1])))
    
```

</br>   

###### 자식노드가 항상 *2, *2+1 형태가 아니여서 틀린 답
```python
def emu(n):
    if node[n] == '/':
        node[n] = float(node[n*2]) / float(node[n*2+1])
    elif node[n] == '*':
        node[n] = float(node[n*2]) * float(node[n*2+1])
    elif node[n] == '+':
        node[n] = float(node[n*2]) + float(node[n*2+1])
    elif node[n] == '-':
        node[n] = float(node[n*2]) - float(node[n*2+1])


for tc in range(1,11):
    N = int(input())
    node = [0] * (N+1)
    left = [0] * (N+1)
    right = [0] * (N+1)
    for _ in range(N):
        input_li = input().split()
        idx = int(input_li[0])
        if input_li[1].isdigit():
            cnt = int(input_li[1])
        else:
            cnt = input_li[1]
        node[idx] = cnt
        if idx == 1:
            left[idx] = cnt
        else:
            if idx % 2 :
                right[idx] = cnt
            else:
                left[idx] = cnt
    for m in range(N//2,0,-1):
        if type(node[m]) == str:
            if (m*2 <= N) and (m*2+1 <=N):
                emu(m)
    print(int(node[1]))
```
</br>   

<hr>    

### 1486. 장훈이의 높은 선반    
  
```python    

#가지치기 X
def powerset(n):
    global hei_sum, N
    for i in range(1<<N):
        for j in range(N):
            if i & (1<<j):
                pow[i].append(height[j])
        ans = sum(pow[i])
        if ans >= B and (hei_sum > ans):
            hei_sum = ans

T = int(input())
for tc in range(1,T+1):
    N, B = map(int,input().split())
    height = sorted(list(map(int,input().split())))
    hei_sum = 987654321
    pow = [[] for _ in range(1<<N)]
    powerset(height)
    print('#{} {}'.format(tc,hei_sum-B))
```   

</br>   

<hr>   

### 1861. 정사각형 방   

```python   
def check(i,j):
    global cnt
    # 22번 케이스 200*200개 출력하려면 가지치기 필요..어떻게 해야하려나

    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if 0 <= ni < N and 0 <= nj < N:
            if board[i][j] + 1 == board[ni][nj]:
                cnt += 1
                check(ni,nj)
    return



T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [list(map(int,input().split())) for _ in range(N)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    max_cnt = 0
    max_idx = 987654321
    for i in range(N):
        for j in range(N):
            # 현재 방 1개에서 시작
            cnt = 1
            check(i,j)
            if max_cnt == cnt:
                if max_idx > board[i][j]:
                    max_idx = board[i][j]
            if max_cnt < cnt:
                max_cnt = cnt
                max_idx = board[i][j]

    print('#{} {} {}'.format(tc,max_idx, max_cnt))   
```  
```python    
# 다른방법 1 -> 1번에서 2번으로 갈 수 있으면 배열[1] =1 , 3번에서 4번으로 갈 수 있으면 배열[3] = 1 .. 이런식으로 배열을 하나 만들고,
# 뒤에서부터 순회하면서 1이나오면, 0이 나올때까지 cnt +1 -> 최대값보다 크거나 같으면 최대값 갱신하고 마지막으로 1이 나온 번호를 i에 저장하고, 갈 수 있는 방 갯수는, 본인 방도 포함해야하므로 cnt += 1
# 뒤에서부터 순회하므로 최대값이 같더라도, 순회끝나면 그 중 작은 번호가 i에 저장되게 됨


# 다른방법 2 -> 2차원배열을 뒤에서부터 순회하면서 pos배열에 각 방번호의 좌표(i,j) 추가 -> dis =[1]*(N*N+1) 로 1로 초기화
# 그러면 pos[1]은 1번 방의 좌표 등이 들어갈 것이고, pos 배열을 순회하면서 (1번방 좌표에서 2번방 좌표가 상하좌우로 갈 수있는 경우라면
# 즉, 두 방 좌표의 차이가 (1,0), (0,1), (-1,0), (0,-1) 안에 존재한다면, 갈 수 있는 것이므로 dis[i-1] = dis[i]+1 (다음 방번호의 거리 + 1)만큼 추가 (뒤에서부터 순회하므로)
# 그러면서 최대값보다 dis[i-1]가 더 크다면, 최댓값을 갱신하고, 방번호도 갱신
```  
<hr>   
</br>   

### 4366. 정식이의 은행업무    

```python  
# 2진수 계산
def cal_binary(n):
    ans = 0
    li = n[::-1]
    for i in range(len(n)):
        ans += (2**i) * li[i]
    return ans

# 3진수 계산
def cal_trit(n):
    ans = 0
    li = n[::-1]
    for i in range(len(n)):
        ans += (3**i) * li[i]
    return ans


T = int(input())
for tc in range(1,T+1):
    binary = list(map(int,input()))
    trit = list(map(int,input()))
    i = j = 0

    # 가능한 경우의 수를 모두 담을 리스트 reb,ret
    reb = [0] * len(binary)
    ret = [0] * (2*len(trit))

    # 무조건 1자리가 틀리다고 하였으므로 2진수에서 틀린 자릿수 i
    while i < len(binary):
        # 원래 값을 temp에 저장해두고, 바꾼 후 계산하여 reb 리스트에 담고, 다시 원래 값 복구 -> 다음 자리수 변경 반복
        temp = binary[i]
        binary[i] = (binary[i]+1) % 2
        reb[i] = cal_binary(binary)
        binary[i] = temp
        i += 1

    # 3진수는 1,2,3에서 바뀌므로 한 자리에서 바뀔 수 있는 경우가 2가지 존재
    # -> 자릿수 인덱스와 ret 배열에 넣을 인덱스에서 차이가 생겨서, 배열에 넣을 인덱스는 새로운 인덱스 m 사용
    m = 0

    # 3진수에서 틀린 자릿수 j
    while j < len(trit):
        temp2 = trit[j]
        for k in range(1,3):
            trit[j] = (trit[j]+1) % 3
            ret[m] = cal_trit(trit)
            m += 1
        # 해당 자릿수에서 바꿀 수 있는 경우를 반복문을 통해 모두 배열에 넣고, 다시 원래값 복구 후 다음 자릿수 변경 반복
        trit[j] = temp2
        j += 1
    result = 0

    # 가능한 수를 모두 배열에 담았으므로, 배열을 순회하며 같은 값이 존재하면 result에 담고 break
    for i in range(len(ret)):
        for j in range(len(reb)):
            if ret[i] == reb[j]:
                result = ret[i]
                break
        if result:
            break
    print('#{} {}'.format(tc,result))
```   
</br>   
<hr>   

### 2819. 격자판의 숫자 이어붙이기    

```python  
def paste(i,j, ans):
    global cnt
    if len(ans) == 7:
        result.add(ans)
        return
    while i < 4 and j < 4:
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 0 <= ni < 4 and 0 <= nj < 4:
                paste(ni,nj,ans+str(board[ni][nj]))
                ni -= di[k]
                nj -= dj[k]
                i = ni
                j = nj
        return
    return

T = int(input())
for tc in range(1,T+1):
    board = [list(map(int,input().split())) for _ in range(4)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    cnt = 0
    result = set()
    for i in range(4):
        for j in range(4):
            paste(i,j,str(board[i][j]))
    print('#{} {}'.format(tc,len(result)))
```  

#### 다른방법 - 리스트 활용   

```python   
def paste(i,j, ans):
    global cnt
    if len(ans) == 7:
        if ans not in result:
            result.append(ans)
            cnt += 1
        return
    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if 0 <= ni < 4 and 0 <= nj < 4:
            paste(ni,nj,ans+str(board[ni][nj]))

T = int(input())
for tc in range(1,T+1):
    board = [list(map(int,input().split())) for _ in range(4)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    cnt = 0
    result = []
    for i in range(4):
        for j in range(4):
            paste(i,j,str(board[i][j]))
    print('#{} {}'.format(tc,cnt))
```   
</br>   
<hr>   

### 1249. 보급로    
```python   
import collections

def bfs(n):
    que = collections.deque()
    que.append(n)
    arr[n[0]][n[1]] = 0
    while que:
        x,y = que.popleft()
        for k in range(4):
            nx = x + di[k]
            ny = y + dj[k]
            if 0<= nx < N and 0<= ny < N:
                if arr[nx][ny] > arr[x][y] + board[nx][ny]:
                    arr[nx][ny] = arr[x][y] + board[nx][ny]
                    que.append([nx,ny])

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [list(map(int,input())) for _ in range(N)]
    INF = 987654321
    arr = [[INF] * (N) for _ in range(N)]
    di = [-1,1,0,0]
    dj = [0,0,-1,1]
    bfs([0,0])
    print('#{} {}'.format(tc,arr[N-1][N-1]))
```     
</br>   
<hr>    

### 1251. 하나로    
```python   
def prim(n):
    dist[n] = 0
    visited = [0] *(N+1)
    for _ in range(N+1):
        minV = INF
        for i in range(N):
            if visited[i] == 0 and minV > dist[i]:
                w = i
                minV = dist[i]
        visited[w] = 1
        for v in range(N):
            if visited[v] == 0 and arr[w][v] :
                dist[v] = min(dist[v], arr[w][v])

T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    x_board = list(map(int, input().split()))
    y_board = list(map(int, input().split()))
    E = float(input())
    INF = 987654321987654321
    arr = [[0] * N for _ in range(N)]
    for i in range(N-1):
        for j in range(i + 1, N):
            L = (x_board[i] - x_board[j]) ** 2 + (y_board[i] - y_board[j]) ** 2
            w = float(L * E)
            arr[i][j] = w
            arr[j][i] = w
    dist = [INF] * N
    prim(0)
    print('#{} {}'.format(tc, round(sum(dist))))
```    
</br>   
<hr>     

### 7465. 창용 마을 무리의 개수     

```python   
def find_set2(n):
    if p[n] != n :
        p[n] = find_set2(p[n])
    return p[n]

T = int(input())
for tc in range(1,T+1):
    N, M =map(int,input().split())
    p = [i for i in range(N+1)]
    for k in range(M):
        s, e = map(int,input().split())
        p[find_set2(s)] = find_set2(e)
    res = set()
    for v in range(1,N+1):
        res.add(find_set2(v))
    print('#{} {}'.format(tc,len(res)))
```    
- 서로소 집합(disjoint sets) 이용   

</br>   
<hr>          

### 5249. 최소 신장 트리   
```python  
def find_set(n):
    while p[n] != n :
        n = p[n]
    return n
T = int(input())
for tc in range(1,T+1):
    V, E = map(int,input().split())
    arr = []
    for i in range(E):
        n1,n2,w = map(int,input().split())
        arr.append([w,n1,n2]) 
    arr.sort()
    p = [i for i in range(V+1)]
    cnt = res = 0
    for w,n1,n2 in arr :
        if find_set(n1) != find_set(n2):
            cnt += 1
            res += w
            p[find_set(n1)] = find_set(n2)
        if cnt == V:
            break
    print('#{} {}'.format(tc,res))
```  
- 서로소 집합 이용22    

</br>  
<hr>   

### 1865. 동철이의 일 분배     
```python   
def perm(n,k,ans):
    global max_per
    if ans == 0:
        return
    if ans < max_per:
        return
    if k == n:
        if ans > max_per:
            max_per = ans
    else:
        for i in range(k, n):
            arr[k], arr[i] = arr[i], arr[k]
            perm(n,k+1,ans*percent[k-1][arr[k]])
            arr[k], arr[i] = arr[i], arr[k]


T = int(input())
for tc in range(1,T+1):
    N = int(input())
    percent = [list(map(int,input().split())) for _ in range(N)]
    for i in range(N):
        for j in range(N):
            percent[i][j] /= 100
    max_per = 0
    arr = [i for i in range(N)]
    perm(N,0,1)
    print('#{} {:06.6f}'.format(tc,max_per*100))
```   
- 다른 풀이 (처음엔 시간초과 났었는데, 최대값을 갱신하고 리턴을 안해서 시간초과난거였다..)    

```python   
def perm(n,k,ans):
    global max_per
    if ans == 0:
        return
    if ans <= max_per:
        return
    if k == n:
        if ans > max_per:
            max_per = ans
        return
    else:
        for i in range(N):
            if not used[i]:
                p[k] = arr[i]
                used[i] = 1
                perm(n,k+1,ans*percent[k][p[k]])
                used[i] = 0

T = int(input())
for tc in range(1,T+1):
    N = int(input())
    percent = [list(map(int,input().split())) for _ in range(N)]
    for i in range(N):
        for j in range(N):
            percent[i][j] /= 100
    max_per = 0
    used = [0] * (N+1)
    p = [0] * N
    arr = [i for i in range(N)]
    perm(N,0,1)
    print('#{} {:06.6f}'.format(tc,max_per*100))
```     

### 5247. 연산     
```python    
import collections

oper = [['*',2],['+',1],['-',1],['-',10]]

def bfs(n):
    global result, size, end
    que = collections.deque([])
    que.append(n)
    while que:
        res,cnt = que.popleft()
        if cnt > result:
            continue
        else:
            for i in range(4):
                op, n = oper[i]
                res1 = res2 = res3 = 0
                if op == '+':
                    res1 = res+n
                    if res1 < size and visited[res1] == 0 :
                        que.append([res1,cnt+1])
                        visited[res1] = 1
                elif op == '-':
                    res2 = res-n
                    if 0 < res2 < size and visited[res2] == 0:
                        que.append([res2,cnt+1])
                        visited[res2] = 1
                elif op == '*':
                    res3 = res*n
                    if res3 < size and visited[res3] == 0:
                        que.append([res3,cnt+1])
                        visited[res3] = 1
                if res1 == end or res2 == M or res3 == M :
                    result = min(result,cnt+1)

T = int(input())
for tc in range(1,T+1):
    N,M = map(int,input().split())
    start = min(N,M)
    end = max(M,N)
    result = 987654321
    size = 1000000
    visited =[0] * 1000001           # 방문표시안하면 메모리 터짐
    bfs([start,0])
    print('#{} {}'.format(tc,result))  
```    
- 하나의 경우에서 각 연산에 대한 가지를 뻗어나가야하므로 bfs     
- 재귀 dfs로 할 경우 시간초과가 발생하는데, 백트레킹 열심히 하면 될것같기도 하지만 너무 복잡할 것 같아 bfs로 변경     

<hr>   
</br></br>     


### 13349. 광이삼의 암벽등반    
```python   
def dfs(s,e,cnt):
    global ans
    if cnt > ans :
        return
    if abs(e[0] - s[0]) + abs(e[1] - s[1]) <= L:
        ans = min(ans,cnt)
        return
    else:
        for rx,ry in ring:
            if abs(s[0]-rx)+abs(s[1]-ry) <= L and visited[rx][ry] == 0:
                visited[rx][ry] = 1
                dfs([rx,ry],e,cnt+1)
                visited[rx][ry] = 0


T = int(input())
for tc in range(1,T+1):
    M,N,L = map(int,input().split())
    board = [list(map(int,input().split())) for _ in range(M)]
    start = 0
    end = 0
    ring = []
    visited = [[0]*N for _ in range(M)]
    for i in range(M):
        for j in range(N):
            if board[i][j] == 2:
                start = [i,j]
            elif board[i][j] == 3:
                end = [i,j]
            elif board[i][j] == 1:
                ring.append([i,j])

    ans = 20
    dfs(start,end,0)
    if ans > 10 :
        ans = -1
    print('#{} {}'.format(tc,ans))
```    
- dfs 백트래킹 활용     
- 고리 위치를 배열 ring에 모두 넣어두고 하나씩 꺼내가며 현재 위치와 꺼낸 고리 위치 사이의 거리가 갈 수 있는 거리면 진행      
- 시간이 아무래도 오래 걸리는 것 같아 최적화 필요 -> 고리 위치를 모두 배열에 넣는 과정에서 시간이 오래 걸리는 것 같다고 추측 중    

<hr>   
</br> </br>     

### 5251. 최소 이동 거리    
```python    
def dijkstra(s):
    global dist
    visited = [0] * (N+1)       # 도로번호만큼 방문 배열 생성
    visited[s] = 1      # 시작지점 방문 표시
    dist = [0] * (N+1)      # 거리 표시할 배열 생성
    for i in range(N+1):
        dist[i] = arr[s][i]     # 시작지점부터 i까지의 거리로 dist배열 초기화
    for _ in range(N+1):
        minV = INF
        v = 0
        for k in range(N+1):        # 방문하지 않았으면서, 구간거리가 최소인 값 찾기
            if visited[k] == 0 and minV > arr[s][k] :
                minV = arr[s][k]
                v = k
        visited[v] = 1      # 선택한 해당 도로번호 방문 표시
        # 시작점부터 v까지 이동하는 최소 거리는 찾았으므로, v부터 각 도로 번호까지의 최소거리를 찾아야함
        for m in range(N+1):
            dist[m] = min(dist[m], dist[v]+arr[v][m])   # 시작부터 m까지 가는게 더 짧은지, 시작점에서 v에서 m으로 거쳐가는게 더 짧은지 갱신

T = int(input())
for tc in range(1,T+1):
    N, E = map(int, input().split())
    INF = 20        # 구간거리 최대값은 10이므로 적당히 20으로 설정
    arr = [[INF] * (N+1) for _ in range(N+1)]   # 가중치 배열 arr 초기화
    for _ in range(E):
        s,e,w = map(int,input().split())
        arr[s][e] = w
    # 이렇게 되면 인접한 구간에만 구간거리가 갱신됨
    dijkstra(0)
    print('#{} {}'.format(tc,dist[N]))    
```   

<hr?    
</br></br>   

### 1231. 중위순회    
```python   
def inorder(n):
    if n:
        inorder(adjList[n][0])      # 왼쪽
        result.append(G[n])
        inorder(adjList[n][1])      # 오른쪽

for tc in range(1,11):
    N = int(input())    # 정점의 수
    nums = [input().split() for _ in range(N)]
    for k in range(N):
        nums[k].append(0)
        nums[k].append(0)
    G = [0] + [nums[i][1] for i in range(N)]
    adjList = [[0,0] for _ in range(N+1)]
    for j in range(N):
        p = int(nums[j][0])
        if adjList[p][0] == 0:
            if nums[j][2] != 0:
                c_l = int(nums[j][2])
                adjList[p][0] = c_l
        if adjList[p][0] and nums[j][3] != 0:
            c_r = int(nums[j][3])
            adjList[p][1] = c_r
    result = []
    inorder(1)
    print('#{} {}'.format(tc, ''.join(map(str,result))))
```    
<hr>   
</br></br>    

### 1227. 미로2    
```python   
def bfs(s,v):
    q = []          # 큐 생성
    q.append(s)     # 시작점 인큐    #enQ
    si , sj = s[0], s[1]
    visited[si][sj] = 1  # 시작점 방문표시
    while q:
        t1, t2 = q.pop(0)    # 큐에서 하나 꺼내서 t에 저장 #deQ
        for w in adjList[t1][t2]:       # 갈 수 있는 곳 w 순회
            w1,w2 = w[0],w[1]
            if visited[w1][w2] == 0:    # 미방문했다면
                if w == v:
                    return 1
                else:
                    q.append(w)             # 정점 인큐
                    visited[w1][w2] = visited[t1][t2] + 1
    return 0

for _ in range(1,11):
    tc = int(input())
    N = 100
    maze = [list(input()) for _ in range(N)]
    visited = [[0 for _ in range(N)] for _ in range(N)]
    adjList = [[[] for _ in range(N)] for _ in range(N)]
    for i in range(N):
        for j in range(N):
            if maze[i][j] == '2':
                s = [i,j]               # 시작점 인덱스
            elif maze[i][j] == '3':
                e = [i,j]               # 도착점 인덱스
    di = [1,-1,0,0]
    dj = [0,0,1,-1]
    for i in range(N):
        for j in range(N):
            for k in range(4):
                ni = i + di[k]
                nj = j + dj[k]
                if 0 <= ni < N and 0 <= nj < N:
                    if maze[ni][nj] != '1':
                        adjList[i][j].append([ni,nj])

    print('#{} {}'.format(tc, bfs(s,e)))
```    
- bfs 로 풀이한 방식    
- dfs로 풀이하면 아래와 같이 된다.    
    ```python    
    def dfs(s,v):
    stack = []          # 스택 생성
    a = s     # 현재 방문 지점
    si, sj = s[0], s[1]
    visited[si][sj] = 1
    while True:
        a1,a2 = a[0], a[1]
        for w in adjList[a1][a2]:
            w1, w2 = w[0], w[1]
            if w == v:
                return 1
            if visited[w1][w2] == 0:
                stack.append(a)
                a = w
                visited[w1][w2] = 1
                break
        else:                       # 갈 수 있는 곳이 없다면
            if stack:               # 스택에 남아있으면 그곳으로 돌아가기
                a = stack.pop()
            else:                   # 스택이 비어있으면 더이상 갈 곳이없음
                break
    return 0


    for _ in range(10):
        tc = int(input())
        N = 100
        maze = [list(input()) for _ in range(N)]
        visited = [[0 for _ in range(N+1)] for _ in range(N+1)]
        adjList = [[[] for _ in range(N)] for _ in range(N)]
        di = [1,-1,0,0]
        dj = [0,0,1,-1]
        for i in range(N):
            for j in range(N):
                if maze[i][j] == '2':
                    s = [i,j]
                elif maze[i][j] == '3':
                    e = [i,j]
                for k in range(4):
                    ni = i + di[k]
                    nj = j + dj[k]
                    if 0 <= ni < N and 0 <= nj < N and (maze[ni][nj] != '1'):
                        adjList[i][j].append([ni,nj])
    print('#{} {}'.format(tc,dfs(s,e)))
    ```     
    
<hr>    
</br></br>     

