# D4 난이도    
</br>   

## 정답 코드   

### 1232. 사칙연산

```python
def emu(n):
    li = node[:]
    if li[n] == '/':
        li[n] = float(li[left[n]]) / float(li[right[n]])
    elif node[n] == '*':
        li[n] = float(li[left[n]]) * float(li[right[n]])
    elif node[n] == '+':
        li[n] = float(li[left[n]]) + float(li[right[n]])
    elif node[n] == '-':
        li[n] = float(li[left[n]]) - float(li[right[n]])
    return li

for tc in range(1,11):
    N = int(input())
    node = [0] * (N+1)
    left = [0] * (N+2)
    right = [0] * (N+2)
    for _ in range(N):
        input_li = input().split()
        idx = int(input_li[0])
        if input_li[1].isdigit():
            node[idx] = int(input_li[1])
        else:
            node[idx] = input_li[1]
            left[idx] = int(input_li[2])
            right[idx] = int(input_li[3])
    for m in range(N,0,-1):
        if type(node[m]) == str:
            node = emu(m)

    print('#{} {}'.format(tc, int(node[1])))
    
```

</br>   

###### 자식노드가 항상 *2, *2+1 형태가 아니여서 틀린 답
```python
def emu(n):
    if node[n] == '/':
        node[n] = float(node[n*2]) / float(node[n*2+1])
    elif node[n] == '*':
        node[n] = float(node[n*2]) * float(node[n*2+1])
    elif node[n] == '+':
        node[n] = float(node[n*2]) + float(node[n*2+1])
    elif node[n] == '-':
        node[n] = float(node[n*2]) - float(node[n*2+1])


for tc in range(1,11):
    N = int(input())
    node = [0] * (N+1)
    left = [0] * (N+1)
    right = [0] * (N+1)
    for _ in range(N):
        input_li = input().split()
        idx = int(input_li[0])
        if input_li[1].isdigit():
            cnt = int(input_li[1])
        else:
            cnt = input_li[1]
        node[idx] = cnt
        if idx == 1:
            left[idx] = cnt
        else:
            if idx % 2 :
                right[idx] = cnt
            else:
                left[idx] = cnt
    for m in range(N//2,0,-1):
        if type(node[m]) == str:
            if (m*2 <= N) and (m*2+1 <=N):
                emu(m)
    print(int(node[1]))
```
</br>   

<hr>    

### 1486. 장훈이의 높은 선반    
  
```python    

#가지치기 X
def powerset(n):
    global hei_sum, N
    for i in range(1<<N):
        for j in range(N):
            if i & (1<<j):
                pow[i].append(height[j])
        ans = sum(pow[i])
        if ans >= B and (hei_sum > ans):
            hei_sum = ans

T = int(input())
for tc in range(1,T+1):
    N, B = map(int,input().split())
    height = sorted(list(map(int,input().split())))
    hei_sum = 987654321
    pow = [[] for _ in range(1<<N)]
    powerset(height)
    print('#{} {}'.format(tc,hei_sum-B))
```   

</br>   

<hr>   

### 1861. 정사각형 방   

```python   
def check(i,j):
    global cnt
    # 22번 케이스 200*200개 출력하려면 가지치기 필요..어떻게 해야하려나

    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if 0 <= ni < N and 0 <= nj < N:
            if board[i][j] + 1 == board[ni][nj]:
                cnt += 1
                check(ni,nj)
    return



T = int(input())
for tc in range(1,T+1):
    N = int(input())
    board = [list(map(int,input().split())) for _ in range(N)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    max_cnt = 0
    max_idx = 987654321
    for i in range(N):
        for j in range(N):
            # 현재 방 1개에서 시작
            cnt = 1
            check(i,j)
            if max_cnt == cnt:
                if max_idx > board[i][j]:
                    max_idx = board[i][j]
            if max_cnt < cnt:
                max_cnt = cnt
                max_idx = board[i][j]

    print('#{} {} {}'.format(tc,max_idx, max_cnt))   
```  
```python    
# 다른방법 1 -> 1번에서 2번으로 갈 수 있으면 배열[1] =1 , 3번에서 4번으로 갈 수 있으면 배열[3] = 1 .. 이런식으로 배열을 하나 만들고,
# 뒤에서부터 순회하면서 1이나오면, 0이 나올때까지 cnt +1 -> 최대값보다 크거나 같으면 최대값 갱신하고 마지막으로 1이 나온 번호를 i에 저장하고, 갈 수 있는 방 갯수는, 본인 방도 포함해야하므로 cnt += 1
# 뒤에서부터 순회하므로 최대값이 같더라도, 순회끝나면 그 중 작은 번호가 i에 저장되게 됨


# 다른방법 2 -> 2차원배열을 뒤에서부터 순회하면서 pos배열에 각 방번호의 좌표(i,j) 추가 -> dis =[1]*(N*N+1) 로 1로 초기화
# 그러면 pos[1]은 1번 방의 좌표 등이 들어갈 것이고, pos 배열을 순회하면서 (1번방 좌표에서 2번방 좌표가 상하좌우로 갈 수있는 경우라면
# 즉, 두 방 좌표의 차이가 (1,0), (0,1), (-1,0), (0,-1) 안에 존재한다면, 갈 수 있는 것이므로 dis[i-1] = dis[i]+1 (다음 방번호의 거리 + 1)만큼 추가 (뒤에서부터 순회하므로)
# 그러면서 최대값보다 dis[i-1]가 더 크다면, 최댓값을 갱신하고, 방번호도 갱신
```  
<hr>   
</br>   

### 4366. 정식이의 은행업무    

```python  
# 2진수 계산
def cal_binary(n):
    ans = 0
    li = n[::-1]
    for i in range(len(n)):
        ans += (2**i) * li[i]
    return ans

# 3진수 계산
def cal_trit(n):
    ans = 0
    li = n[::-1]
    for i in range(len(n)):
        ans += (3**i) * li[i]
    return ans


T = int(input())
for tc in range(1,T+1):
    binary = list(map(int,input()))
    trit = list(map(int,input()))
    i = j = 0

    # 가능한 경우의 수를 모두 담을 리스트 reb,ret
    reb = [0] * len(binary)
    ret = [0] * (2*len(trit))

    # 무조건 1자리가 틀리다고 하였으므로 2진수에서 틀린 자릿수 i
    while i < len(binary):
        # 원래 값을 temp에 저장해두고, 바꾼 후 계산하여 reb 리스트에 담고, 다시 원래 값 복구 -> 다음 자리수 변경 반복
        temp = binary[i]
        binary[i] = (binary[i]+1) % 2
        reb[i] = cal_binary(binary)
        binary[i] = temp
        i += 1

    # 3진수는 1,2,3에서 바뀌므로 한 자리에서 바뀔 수 있는 경우가 2가지 존재
    # -> 자릿수 인덱스와 ret 배열에 넣을 인덱스에서 차이가 생겨서, 배열에 넣을 인덱스는 새로운 인덱스 m 사용
    m = 0

    # 3진수에서 틀린 자릿수 j
    while j < len(trit):
        temp2 = trit[j]
        for k in range(1,3):
            trit[j] = (trit[j]+1) % 3
            ret[m] = cal_trit(trit)
            m += 1
        # 해당 자릿수에서 바꿀 수 있는 경우를 반복문을 통해 모두 배열에 넣고, 다시 원래값 복구 후 다음 자릿수 변경 반복
        trit[j] = temp2
        j += 1
    result = 0

    # 가능한 수를 모두 배열에 담았으므로, 배열을 순회하며 같은 값이 존재하면 result에 담고 break
    for i in range(len(ret)):
        for j in range(len(reb)):
            if ret[i] == reb[j]:
                result = ret[i]
                break
        if result:
            break
    print('#{} {}'.format(tc,result))
```   
</br>   
<hr>   

### 2819. 격자판의 숫자 이어붙이기    

```python  
def paste(i,j, ans):
    global cnt
    if len(ans) == 7:
        result.add(ans)
        return
    while i < 4 and j < 4:
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 0 <= ni < 4 and 0 <= nj < 4:
                paste(ni,nj,ans+str(board[ni][nj]))
                ni -= di[k]
                nj -= dj[k]
                i = ni
                j = nj
        return
    return

T = int(input())
for tc in range(1,T+1):
    board = [list(map(int,input().split())) for _ in range(4)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    cnt = 0
    result = set()
    for i in range(4):
        for j in range(4):
            paste(i,j,str(board[i][j]))
    print('#{} {}'.format(tc,len(result)))
```  

#### 다른방법 - 리스트 활용   

```python   
def paste(i,j, ans):
    global cnt
    if len(ans) == 7:
        if ans not in result:
            result.append(ans)
            cnt += 1
        return
    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        if 0 <= ni < 4 and 0 <= nj < 4:
            paste(ni,nj,ans+str(board[ni][nj]))

T = int(input())
for tc in range(1,T+1):
    board = [list(map(int,input().split())) for _ in range(4)]
    di = [0,1,0,-1]
    dj = [1,0,-1,0]
    #    우 하 좌 상
    cnt = 0
    result = []
    for i in range(4):
        for j in range(4):
            paste(i,j,str(board[i][j]))
    print('#{} {}'.format(tc,cnt))
```   
</br>   
<hr>   


