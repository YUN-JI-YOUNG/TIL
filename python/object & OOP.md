## 객체(object)

- 파이썬에서 객체란? -> 세상에 존재하는 모든 요소

  = 파이썬의 모든 것(변수, 함수, 메소드 등등)은 객체

- 집의 청사진(설계도)이 `클래스`, 실제 집은 `객체`를 나타냄

- 함수(`인자`) **vs** `변수`.메소드()　 -> 함수가 인자를 처리 vs 변수가 메소드를 호출 

  = 흘러가는 것 vs 주도적인 것

- `모든 객체`는 특정 타입(클래스)의 `인스턴스`

  -> 하지만 클래스도 객체가 아닌가?

  -> 클래스도 객체가 맞다. 클래스 객체를 생성하는 클래스를 메타클래스라 부르고, 클래스의 타입을 확인하면 class 'type' 을 확인 가능

  -> 즉, `모든 클래스`는 type 메타클래스의 `인스턴스`    
  
  -> `메타클래스`는 상위가 존재하지 않고, `재귀`로 스스로 반복 호출     

- 모든 인스턴스는 객체

  - `a,b= 1,2` -> a,b는 객체다(O) 

    ​	= a,b는 int class(혹은 type)의 인스턴스다(O)

- 공통된 속성과 조작법을 가진 객체들의 분류 = `타입`

  특정 타입의 실제 데이터 예시 = `인스턴스`

</br>   

### 1. 객체의 특징

- `타입` : 어떤 연산자와 조작(메소드)이 가능한지?　　-> 타입별 사용가능한 연산자,메소드가 다름
- `속성` : 어떤 상태(데이터)를 가지는지?
- `조작법(메소드)` : 어떤 행위(함수)를 할 수 있는가?
    
`help(클래스명)` 으로 해당 클래스에 대한 정보 확인 가능

</br>    

#### 1-1. isinstance 함수

- isinstance(object, classinfo)    
- 객체가 classinfo 클래스로 만들어진 인스턴스 / classinfo 서브클래스로 만들어진 인스턴스인가?      
- classinfo가 튜플(여러개의 type)인 경우, 하나라도 일치하면 True    
- classinfo가 type으로 구성되지 않으면 TypeError 발생    

</br>   

#### 1-2. 객체 - 속성(attribute)

`객체명.속성`  

-> 호출이 아니라 값이 있는 것이므로 ()가 없음

- 속성은 객체의 데이터

- `객체명.imag`  => 객체의 허수부, 즉 속성값 반환

- `def __init__(self, name):      `   -> name에 대한 인자 없이 호출하면 TypeError 발생

  `self.name = name` 처럼 값 받을 속성 정의 -> `print(인스턴스.name)` 등 으로 출력 가능

- `인스턴스 = 클래스('지영')` 같은 식으로 인스턴스 생성 시 속성 데이터 입력

</br>   

#### 1-3. 객체 - 메소드(method)

`객체명.메소드()`

- 메소드는 특정 객체에 적용될 수 있는 행위이며 일반적으로 클래스에 정의된 함수
- 클래스로 만들어진 인스턴스(객체)가 메소드를 호출하는 것
- dir(객체) 함수로 해당 객체가 갖고있는 모든 속성과 메소드 리스트 호출


</br>   


## 객체 지향 프로그래밍(OOP)

###### 프로그램 설계에 현실세계를 반영하여(추상화) 객체로 표현해서 코드를 작성하겠다는 생각 기반

- 프로그래밍 패러다임

  - 기능에 따라 프로그래밍 언어 분류
  - 1. 명령형 프로그래밍(프로그래머가 기계에게 상태 변경 방법 지시)
       - 절차 지향 프로그래밍
       - **객체 지향 프로그래밍**
    2. 선언형 프로그래밍
- `객체 지향 프로그래밍(Object-Oriented Programming)`은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 `'객체'들의 모임`으로 파악하고자 하는 것

  - 절차 지향(절차적) 프로그래밍은 함수 호출을 통해 코드의 추상화, 재사용성을 획득 

    = 데이터와 함수로 인한 변화, 함수가 데이터를 넣어서 호출

    -> 하나의 `큰 맥락`이 있어 중간중간 변경은 `어려움` > 뒷부분 싹 다 바꿔야 할 수도..

  - 객체 지향 프로그래밍은 데이터와 기능을 `분리`하고 각각을 `추상화`하여 객체로 분리 

    -> 특정 기능을 수행하려면 메소드를 직접 호출, 객체가 좀 더 주체적인 입장

    -> 장점 : 코드의 `직관성`, 활용의 `용이성`, 변경의 `유연성`

    즉, 유연하고 변경이 용이하게 만들기 때문에 `대규모 소프트웨어 개발`에 많이 사용, 프로그래밍을 더 배우기 쉽게 하고 sw 개발과 보수를 쉽게 하고, 배우기 더 직관적

  

- 클래스 내에서 속성, 함수(행동)를 정의

  -> 해당 속성을 가지고 해당 함수(행동)을 할 수 있는 인스턴스 생성

  -> 즉, class 라는 틀로 개별적인 인스턴스를 생성하고 나면, 각 인스턴스는 class 틀 안에 정의했던 동작(함수)들을 메소드로 호출하여 각자 다르게 수행할 수 있다.

- 변수를 할당하는 모든 과정은 특정 클래스(타입)의 인스턴스를 생성하던 것

  

- 함수를 정의하고 해당 함수를 호출해서 인자를 넣어 처리하는 절차지향 프로그래밍과 달리

  객체지향 프로그래밍은 클래스를 정의하고 해당 클래스로 인스턴스를 생성한 뒤, 그 인스턴스가 메소드(클래스 내에 정의된 함수)를 호출하여 처리

</br>    

### 1. 클래스와 인스턴스

- 클래스 정의 `class MyClass:` 
  - `파스칼 케이스` 사용 -> 첫 글자 대문자, 단위 이루는 첫글자를 대문자로
    - 파이썬에선 스네이크 케이스였었던 것과 차이
- 인스턴스 생성 `my_instance = MyClass()`
- 메소드 호출 `my_instance.my_method()`
- 속성 `my_instance.my_attribute`

클래스를 정의하고, 인스턴스들을 만들어 활용함.

-> 클래스 : 객체들의 분류(class) (=설계, 청사진 역할)

- 클래스 정의 아래에 """ (docstring)을 통해 설명도 함께 정의 가능 

  -> 이후 `print(인스턴스.__doc__)`로 출력 가능

- 클래스 객체를 생성하는 클래스를 메타클래스라 부르고, type(class) =  'type' 으로 타입 확인 가능

- 'type' 이라는 메타 클래스는 상위가 없고, 재귀적으로 호출

-> 인스턴스 : 하나하나의 실체/예(instance) = 정의된 클래스에 속하는 객체

- type(instance) = class 로 인스턴스의 타입을 확인하면 인스턴스를 만들어낸 클래스 출력

</br>   

`ex)` 사각형의 넓이와 둘레 구하기

- class - 사각형
- 사각형(class)의 정보 - 속성
  - 가로 및 세로 길이
- 사각형(class)의 행동 - 메소드
  - 넓이, 둘레

> 속성을 가진 인스턴스가 각자 생성
>
> > 인스턴스.메소드  -> 넓이,둘레 계산
> >
> > 인스턴스.속성 -> 가로 세로 길이

</br>    

### 2. self

###### 인스턴스 자기자신

`'apple'.capitalize()` 에서 capitalize(self, / ) 로 정의되어 있는 메소드를 호출하면 첫번째 인자로 인스턴스 자기자신 'apple'을 호출하는 것

=>  `str.capitalize('apple')` 실제로는 이렇게 `클래스`가 `호출`하여 `인스턴스`를 `매개`로 동작하지만 

객체지향적 축약형`'apple'.capitalize()` 으로 사용

-> self 인자가 없다면 인스턴스는 메소드를 호출할 수 없음

-> 매개변수 이름이므로 self 가 아닌 다른 이름을 써도 가능은 하지만 하면 `안됨`

- 파이썬에서 `인스턴스 메소드`는 호출 시 첫 인자로 인스턴스 자신이 전달되게(`self`) 설계해야 호출 가능

</br>    

### 3. 생성자(constructor)와 소멸자(destructor)

###### 생성자 소멸자 없이도 클래스 정의 가능

#### (1) 생성자(constructor)

###### 인스턴스 객체가 생성될 때 자동으로 호출되는 메소드
```python
def __init__(self):
print('인스턴스 생성')  # -> 인스턴스 생성할 때 해당 문자열 출력 
```
- init는 초기화라는 뜻으로 생성될 때 사용
- 생성자 메서드로 생성과 동시에 속성에 값을 할당할 수 있기 때문에 일반적으로 생성자 메서드에 주로 속성 정의 작성        
(반드시 생성자 메서드에 작성해야 하는 것은 아님)

</br>    

#### (2) 소멸자(destructor)

###### 인스턴스 객체가 소멸되기 직전에 호출되는 메소드
```python
def __del__(self):
print('인스턴스 소멸')  # -> del로 인스턴스 삭제할 때 해당 문자열 출력
```
</br>     

### 4-1. 인스턴스 변수

- 인스턴스의 `속성`이며, 각 인스턴스들의 `고유한 변수`
- 클래스에 저장 X, 클래스에 생성된 `개별 객체`에 저장
- 인스턴스마다 완전 `독립적`이므로 값을 수정하면 해당 인스턴스에만 영향
- `self.name =  ` 로 정의하고 이후 `인스턴스.name` 으로 접근 및 할당

</br>   

### 4-2. 클래스 변수

- 클래스의 `속성`이며, 클래스 자체의 내용 저장

- 모든 클래스 인스턴스에서 `공유하는 데이터`를 위한 변수       

- `인스턴스.변수명`처럼 인스턴스로 접근은 가능하지만, 인스턴스로 클래스 변수에 접근하여 값 변경하면, 

  클래스 변수가 변하는 것이 아니라 해당 인스턴스에 클래스 변수와 이름이 같은 인스턴스 변수가 생성되는 것 

  -> 이제 더이상 `인스턴스.변수명`으로 해당 클래스 변수에 접근할 수 없음 

  -> `인스턴스.__class__.클래스변수` 로 접근은 가능하지만 이걸 사용할 생각을 하면 안됨

  --> 클래스 변수는 `클래스에서만` 변경해야 함

- 클래스 변수와 같은 이름으로 인스턴스 변수 생성하면 안됨 

  => 클래스 변수는 동일한 이름의 인스턴스 변수에 의해 가려질 수 있어 주의

  (버그, 원치않는 동작 유발 가능)

- 같은 클래스에서 생성된 모든 객체는 동일한 클래스 변수 공유

- 클래스 선언 내부(+ 인스턴스 메소드 밖)에서 정의하고, `클래스명.변수명`으로 접근 및 할당

</br>    

### 4-3. 인스턴스 <-> 클래스 의 이름 공간

- 클래스를 정의하면 클래스 & 클래스 이름 공간 생성
- 인스턴스 생성하면, 인스턴스 객체 & 인스턴스별 이름 공간 생성 -> 서로 영향 X

- 인스턴스가 변수를 찾는 `순서` : 자기자신 -> 클래스 -> 전역     
- 클래스 -> 인스턴스는 접근 `불가`

</br>   

### 5. 매직 메소드

###### 던더 스코어라고도 하며, 더블 언더스코어(`__`)가 있는 메소드

- 특수한 동작을 위해 내부에 구현한 메소드이며 스폐셜 메소드 or 매직 메소드라고 불림

- 대소비교할 때 자동으로 호출되는 매직 메소드 `예시`

  `__lt__(self ,other)` = less than  `__gt__(self, other)` = greater than

  `__le__(self,other)` = less equal  `__ge__(self,other)` = greater equal    등등
  
```python
def __gt__(self,other):
  return self.속성 > other.속성      # 이런식으로 정의하고 나면 이후 > 연산자 사용 가능
```
    
- `+` = `__add__` 

```python
def __str__(self):    # 인스턴스의 출력 형태 지정

return f'길이 : {self.a}'  # -> 여기서 a는 속성

x = class(4)

print(x)                # 길이 : 4 로 출력
```
      
- `dir() 함수`로 해당 객체에 대한 모든 메소드 목록 출력 가능     

</br>    

### 6. 메소드의 종류     

- 메소드는 해당 함수에서 어떤 값을 활용,변경하는지에 따라 정의

- 추가로 매개변수를 더 넣는다면, 해당 메소드 호출 시 `반드시` 매개변수에 대한 인자가 필요하고, 인자가 없다면 `기본값`을 설정하는 등으로 `함수 사용법`과 `동일`

- 클래스 속성 `접근 여부`에 따라 클래스 메소드. 스태틱 메소드로 정의

  -> 클래스 설계에 대한 `개발자의 의도`를 전달하고 강제하여 버그로 설계를 깨뜨리지 않게 하여 `코드의 유지보수`를 하는데 많은 도움

  -> 스태틱 메소드를 사용할 때의 `의도` : 클래스나 인스턴스에 영향을 끼치지 않는다

  -> 사용자에게 제한 없이 자유를 주면 지옥이 펼쳐질 수도..거의 유지보수 포기 수준       
      
#### (1) 인스턴스 메소드    

- 인스턴스가 사용할 메소드이며, 클래스 내부에 정의되는 메소드들은 `기본적`으로 모두 인스턴스 메소드

- `첫 인자`로 `self`가 있으면 무조건 인스턴스 메소드 = 인스턴스 정보 활용

- 세 메소드에 모두 접근 가능하지만 하면 안되므로, 인스턴스의 동작은 `반드시` 인스턴스 메소드로 정의(설계)

  -> 클래스 자체에 접근하여 상태를 수정할 수 있지만 `하면 안되는 것`    
  
</br>   

#### (2) 클래스 메소드   

- 클래스가 사용(호출)할 메소드이며 함수 위쪽에 `@classmethod(데코레이터)` 를 사용하여 정의
- 기존 함수에 원본 기능을 유지한 상태로 기능적인 것을 꾸며주는 것
- `첫 인자`로 `cls`가 전달 = 인스턴스가 아닌 클래스 자기자신이 들어간다 = 클래스 정보 활용
- cls 인자에만 접근 가능하므로 객체 인스턴스 상태 수정은 `불가` = self 인자를 넣을 방법이 없어서 인스턴스 메소드 `사용 불가`
- 클래스의 변수,속성 변경 가능

</br>    

#### (3) 스태틱 메소드    
###### 정적 메소드라고도 함    

- 클래스가 사용(호출)할 메소드이며, `@staticmethod` 데코레이터를 사용하여 정의

- self, cls 전달 X = 클래스 정보에 접근 및 수정 불가 = 어떠한 객체의 정보도 활용하지 X

  -> 객체 인스턴스,클래스 상태에 접근할 수 없음을 보장

- 대신, 임의 개수의 매개 변수 받을 수 있음 -> `독자적`인 메소드

- `일반 함수`처럼 동작하지만, `클래스` 이름공간에 `귀속`되며, 주로 해당 클래스로 한정하는 용도로 사용

- 일반 함수 사용하는 것처럼 실행할 수 있어, 객체 지향<-> 절차 지향 스타일 사이를 `연결`하는 역할

- 인스턴스, 클래스에 영향을 주지 않기때문에 `별도의 연산` 혹은 `테스트 코드` 작성할 때 유용

</br>      
     
### 7. 상속     

부모 클래스의 속성을 그대로 유지한 상태로 각자 클래스의 속성을 추가로 가진 서브 클래스를 생성    

'사람' 이라는 클래스 내에서 직업을 분류하고자 할 때, 상속 없이 각 클래스를 정의하면 메소드가 중복    

-> 중복을 피하기 위해 '사람' 클래스 속성을 상속받아서 메소드는 재사용하면서 따로 필요한 인스턴스 변수만 추가   

- 클래스는 상속이 가능   
- 상속을 통해 객체 간의 관계 구축   
- 부모 클래스의 속성, 메소드가 자식 클래스에 그대로 상속되므로 코드 재사용성이 높아짐   
- `class 자식(부모):` 처럼 상속   
- 코드의 유지보수관리 용이하게 하기 위한 목적   
- 서브클래스는 부모클래스의 인스턴스 = 서브클래스로 만든 인스턴스는 부모클래스의 인스턴스라고도 할 수 있음    

- `super().__init__(name, age 등의 변수)` : 자식클래스에서 부모클래스를 사용하고 싶은 경우     

  -> 부모클래스의 생성자 인자를 가져옴 = 중복 방지      
  
  </br>    

#### 7-1. 메소드 오버라이딩    

  - 상속 받은 메소드 재정의

  - 상속받은 클래스에서 같은 이름의 메소드로 덮어씀 = 부모 클래스의 메소드를 자식 클래스의 같은 이름의 메소드로 덮어씌우기

    -> 부모 클래스의 메소드를 사용하고 싶으면 `super()` 사용

- 상속 관계에서의 이름 공간 탐색 : 인스턴스 -> 자식 클래스 -> 부모 클래스

</br>    

#### 7-2. 다중 상속

- 2개 이상의 클래스를 상속 받는 경우 다중 상속

- class A (B,C)  : A가 B 클래스 상속받고, C 클래스를 상속받음 -> 상속 순서 주의

  -> 중복된 속성 or 메소드가 있으면 상속 순서에 의해 결정

</br>    

* * * * *

##### ※ 참고 : 객체 비교

- `==` 
  - 동등한(`equal`)
  - 변수가 참조하는 객체가 내용이 같으면 true
  - 고양이 2마리는 동등하다(=고양이)
- `is` 
  - 동일한(`identical`)
  - 두 변수가 동일한 객체를 가리키면 true
  - 고양이 2마리는 서로 동일하지 않다(=서로 세부적인 특징이 다름)    


