## Vue CLI        

### SFC (Single File Component)       

Vue 컴포넌트  === Vue 인스턴스  === `.vue` 파일         

- Vue 컴포넌트 기반 개발의 핵심 특징       
  - 컴포넌트    
    - 기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 캡슐화하는데 도움    
    - CS에서는 다시 사용할 수 있는 범용성을 위해 개발된 소프트웨어 구성요소 의미    
    - 유지보수를 쉽게 만들어주며 재사용 측면에서옫 매우 강력한 기능 제공     



- 1개의 컴포넌트 === `.vue` 확장자를 가진 하나의 파일 안에서 작성되는 코드의 결과물    

- 화면의 특정 영역에 대한 HTML, CSS, JS 코드를 하나의 파일 `.vue` 에서 관리    

  = `.vue` 확장자를 가진 싱글 파일 컴포넌트를 통해 개발하는 방식       

- 단일 파일에서의 개발   

  - 처음 개발 시작할 때는 크게 신경쓸것이 없어 쉽게 개발 가능   

  - But, 코드의 양이 많아지면 변수관리가 힘들고 유지보수에 많은 비용    

    -> 그러므로 각 기능별로 파일을 나눠서 개발   

     - 처음 개발을 준비하는 단계에선 시간 소요가 증가하지만 이후 변수 관리 용이 + 기능별로 유지 보수 비용 감소      

- 한 화면 안에서도 기능 별로 각기 다른 컴포넌트 존재    

  - 각 컴포넌트는 여러개의 하위 컴포넌트 보유 가능    

- Vue 컴포넌트는 `const app = new Vue({})` 의 app을 의미 (= Vue 인스턴스 )        

  - 컴포넌트 기반의 개발이 반드시 파일 단위로 구분되어야 하는 것은 X    
  - 단일 `.html` 파일 안에서도 여러개의 컴포넌트를 만들어 개발 가능    

</br>    
<hr>   

### Vue CLI     

###### Vue Commend Line Interface    

- vue.js 개발을 위한 표존 도구   

- 프로젝트 구성을 도와주는 역할이며 Vue 개발 생태계에서  표준 tool 기준을 목표    

- 확장 플러그인, GUI, ES2015 구성요소 제공 등 다양한 tool 제공        

- 설치   

  -  `npm install -g @vue/cli`       

  - 버전 확인 -> `vue --version`    


</br>    

### node.js     

###### JavaScript Runtime Environment    

- 자바스크립트를 브라우저가 아닌 환경에서도 구동할 수 있도록 하는 JS 런타임 환경    
  - 브라우저 밖을 벗어날 수 없는 JS 언어의 태생적 한계 해결  
- 크롬 V8 엔진 제공   
  - 여러 OS 환경에서 실행 가능    
- 단순히 브라우저만 조작할 수 있던 JS를 SSR 아키텍처에서도 사용가능하도록 함    
- 2009 Ryan Dahl에 의해 발표    
- NPM (node pakage manager)    
  - 자바스크립트 언어를 위한 패키지 관리자    
    - 파이썬의 `pip` 와 동일하게 다양한 의존성 패키지 관리   
  - Node의 기본 패키지 관리자이며 Node 설치 시 함께 설치          

</br> 
<hr>   

### Vue 프로젝트 파일 구조         

- Vue CLI는 Babel, Webpack에 대한 초기 설정이 자동으로 설정       

#### Babel   

###### JavaScript compiler    

- `babel.config.js `     

- 자바스크립트의 ECMAScript 2015+코드를 이전 버전으로 번역, 변환해주는 도구   

- 과거 JS의 파편화와 표준화의 영향으로 코드의 스펙트럼이 매우 다양    

  - 그래서 최신 문법을 사용해도 이전 브라우저 or 환경에서 동작하지 않는 문제 발생    

- 원시코드(최신)를 목적 코드(구버전)으로 옮기는 번역기가 등장   

  -> 더이상 코드가 특정 브라우저에서 동작하지 않는 상황에 대해 크게 고민 X        

</br>    

#### node_modules    

- node.js 환경의 여러 의존성 모듈     

- 현재 환경에 대한 패키지 목록          

  -> 가상환경은 아니지만, 파이썬의 venv와 유사   

  => git에는 올라가지 않기때문에 만약 pull을 받았다면,      

  `npm install` 또는 `npm i` 명령어를 통해 동일 환경 세팅 가능       

- node.js를 이루고 있는 환경       

</br>    

#### Webpack       

###### static module bundler    

- **node_modules 내부**에 존재    

- 모듈 간의 의존성 문제를 해결하기 위한 도구   

- 프로젝트에 필요한 모든 모듈 매핑(문제없이 하나로 통합) + 내부적으로 종속성 그래프 빌드      

- **module**    

  - 스크립트 1개 === 모듈 1개  

    -> 모듈은 파일 1개 의미     

  - 브라우저만 조작가능하던 시기의 JS는 모듈 관련 문법 없이 사용 가능했었다.          

    but, JS와 애플리케이션이 복잡해지고 크기가 커지자 전역 스코프를 공유하는 형태의 기존 개발 방식의 한계 등장    

    -> 그래서 라이브러리를 만들어 필요한 모듈을 언제든 불러오거나 코드를 모듈 단위로 작성하는 등의 다양한 시도 발생     

  - 과거 모듈 시스템 (`AMD`, `CommonJS` , `UMD` ) 들이 존재했지만, 현재는 모듈 시스템이 2015년 표준으로 등재  

    -> 현재는 대부분의 브라우저와 Node.js가 모듈 시스템 지원     

  - Module 의존성 문제    

    - 모듈의 수가 많아지고 라이브러리 or 모듈간의 의존성(연결성)이 깊어지며 특정한 곳에서 발생한 문제가 어떤 모듈 간의 문제인지 파악하기 어려워짐    

      => Webpack은 모듈간의 의존성 문제를 해결하기 위해 등장     

- **Bundler**   

  - 모듈 의존성 문제를 해결해주는 작업 === `Bundling`    
  - 번들링을 해주는 도구가 Bundler   
    - Webpack은 다양한 Bundler 중 하나   
  - 여러 모듈을 하나로 묶어주고, 묶은 파일은 하나 or 여러개로 합침         
  - 번들링된 결과물은 더이상 순서에 영향받지 않고 동작   
  - 이외에도 `snowpack` , `parcel` , `rollup.js` 등의 다양한 모듈 번들러 존재         

</br>    

#### pubilc / index.html   

- Vue 앱의 뼈대    
- 실제 제공되는 단일 html 파일   

</br>    

#### src /  

- /assets   
  - webpack에 의해 빌드 된 static 파일 (정적 파일)   
- /components    
  - 하위 컴포넌트들(`.vue`)이 위치       
- / App.vue  
  - 최상위 컴포넌트        
- / main.js    
  - webpack이 빌드 시작시에 가장 먼저 불러오는 entry point    
  - 실제 단일 파일에서 DOM과 data를 연결했던것과 동일한 작업이 이루어지는 곳    
  - Vue 전역에서 활용할 모듈을 등록할 수 있는 파일     

</br>    

#### package.json   

- 프로젝트의 종속성 목록 + 지원되는 브라우저에 대한 구성 옵션  포함      
- package-lock.json과는 달리 무언가 패키지를 설치하면 계속 갱신됨      

</br>    

#### package-lock.json   

- node_modules에 설치되는 모듈과 관련된 모든 의존성 설정 및 관리    

- 팀원 및 배포환경에서 정확히 동일한 종속성을 설치하도록 보장하는 표현     

- 사용할 패키지의 버전 고정 + 개발 과정간 의존성 패키지 충돌 방지           

  - package.json과 달리 어느 한 시점을 고정시킬 수 있음 (== requirements.txt )    

    -> 업데이트 때문에 호환성 및 안정성 문제 등이 생기는 걸 방지할 수 있음     

- `requirements.txt` 와 비슷하지만 훨씬 용량 ↑         
