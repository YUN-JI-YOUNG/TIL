## 변수와 식별자   

- 식별자는 변수를 구분할 수 있는 변수명이며, 문자, 달러($), 밑줄(_) 등으로 시작    

- 대소문자를 구분하며, 클래스명 외에는 모두 소문자로 시작   

- 예약어 사용 불가   

- 식별자 작성 스타일   

  - 카멜 케이스  

    - 변수, 객체, 함수 사용  

    - 소문자로 구성    

      두번째 단어부터 첫글자는 대문자 (`camelCase`)      

  - 파스칼 케이스  

    - 클래스, 생성자에 사용    
    - 대문자로 구성   

  - 대문자 스네이크 케이스    

    - 상수(변경될 가능성이 없는 값)에 사용    
    - `ex>` API_KEY, PI 등   



- 변수 선언 키워드   

  | const                                   | let                                     | var                                                          |
  | --------------------------------------- | --------------------------------------- | ------------------------------------------------------------ |
  | ES6에서 사용 권장                       | ES6에서 사용 권장                       | ES6 이전에서 사용                                            |
  | **재할당 불가**                         | **재할당 가능**                         | 재할당 가능                                                  |
  | let num = 10<br />num = 5 <br />-> 불가 | let num = 10 <br />num = 5<br />-> 가능 | 호이스팅 되는 특성으로 인해 <br />예기치 못한 문제 발생 가능 |
  | 재선언 불가                             | 재선언 불가                             | 재선언 가능                                                  |
  | 블록 스코프                             | 블록 스코프                             | 함수 스코프                                                  |

  - 선언 (Declaration)   

    - 변수 생성    

    - 기본적으론 `undefined` 가 할당되어 있음     

    - `const`, `let` 둘 다 기본적으론 재선언 불가하지만,  

      브라우저 개발자도구에서만 재선언 가능한 것 처럼 보일 수 있음   

      -> 한 단락에 같이 쓰면 원래처럼 에러 발생   

      ```javascript
      let num = 10
      // undefined
      let num = 5
      // undefined
      
      let numb = 10
      let numb = 4
      // Uncaught SyntaxError: Identifier 'numb' has already been declared
      ```

      

  - 할당 (Assignment)   

    - 선언된 변수에 값을 저장    

  - 초기화 (Initialization)   

    - 선언된 변수에 처음으로 값을 저장      

  - 블록 스코프   

    - if, for, 함수 등의 중괄호 내부      

    - 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가     

      ```javascript
      lex x = 1	// 선언 및 초기화 할당
      
      if ( x== 1 ){
          let x = 2		// 블록 스코프내에선 처음 선언한 것므로 재선언 아님
          console.log(x)   // 2 - 블록스코프 내의 x 값은 2
      }
      console.log(x)       // 1 - 블록스코프 바깥에서의 x 값은 1
      ```

  - 함수 스코프    

    - 함수의 중괄호 내부    
    - 함수 스코프를 가지는 변수는 함수 바깥에서 접근 불가    

  

  - 호이스팅  

    - 변수를 선언 이전에 참조 가능한 현상   

    - 변수 선언 이전에 접근 시, `undefined` 반환   

      ```javascript
      console.log(num)   // undefined
      var num = 10
      
      // let, const를 위처럼 쓰면 참조 에러 발생   
      ```

</br>     



## 데이터 타입   

- 원시타입 (Primitive type)    

  - 변수에 해당 타입의 값이 담김    

  - 다른 변수에 복사할 때 실제 값 복사  

  - Number , String, Boolean, undefined, null, Symbol ..   등 객체가 아닌 기본 타입    

    -**Number**    

      - 부동소수점 형식 - 정수, 실수 구분 X      
      - 계산 불가능한 경우 NaN(Not-A-Number) 반환    

    -**String**  

      - 16비트 유니코드 문자의 집합   

      - `' '`, `" "` 모두 가능 -> 엔터로 개행 불가   

        -> 이스케이프 문자로 개행 가능        

      - 템플릿 리터럴   

        - ES6부터 지원   
        - 따옴표 대신 backtick 표현 -> 엔터로 개행 가능   
        - ${expression} 형태로 표현식 삽입 가능       

    -**Boolean**

      - 파이썬과 달리 소문자로 시작    

      - 자동 형변환 규칙      

        | 데이터 타입 | F          | T      |
        | ----------- | ---------- | ------ |
        | undefined   | 항상 F     | X      |
        | null        | 항상 F     | X      |
        | number      | 0, -0, NaN | 그외 T |
        | string      | 빈 문자열  | 그외 T |
        | object      | X          | 항상 T |

    - **undefined**  

      - 변수의 값이 없음을 나타냄        
      - 변수 선언 이후 값을 할당하지 않으면 자동으로 undefined 할당    

    - **null**  

      - 변수의 값이 없음을 의도적으로 표현할 때 사용    

      - null 의 타입은 ECMA 명세의 원시 타입의 정의에 따라 원시타입에 속하지만, `typeof` 연산자를 찍어보면 object 가 나옴   

        -> 일종의 버그이지만 여러 이유로 수정이 불가    

    | undefined                            | null                          |
    | ------------------------------------ | ----------------------------- |
    | 개발자가 의도적으로 필요한 경우 할당 | 자바스크립트가 자동으로 할당  |
    | typeof null  // object               | typeof undefined // undefined |



- 참조타입 (Reference type)     
  - 변수에 해당 객체의 참조 값이 담김   
  - 다른 변수에 복사할 때 참조 값이 복사됨    
    - 파이썬에서의 배열 얕은 복사와 비슷    
  - Objects (Array, Function, etc..)  등 객체 타입의 자료형        




</br>      
